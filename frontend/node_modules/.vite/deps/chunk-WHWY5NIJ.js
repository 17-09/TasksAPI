import {
  require_areEqual,
  require_browser,
  require_createForOfIteratorHelper,
  require_defineProperty,
  require_interopRequireDefault,
  require_objectSpread2,
  require_relay_runtime,
  require_toConsumableArray,
  require_warning
} from "./chunk-5O445XWD.js";
import {
  require_react
} from "./chunk-CANBAPAS.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/react-relay/lib/ReactRelayContext.js
var require_ReactRelayContext = __commonJS({
  "node_modules/react-relay/lib/ReactRelayContext.js"(exports, module) {
    "use strict";
    var React = require_react();
    var _require = require_relay_runtime();
    var createRelayContext = _require.__internal.createRelayContext;
    module.exports = createRelayContext(React);
  }
});

// node_modules/react-relay/lib/relay-hooks/ProfilerContext.js
var require_ProfilerContext = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/ProfilerContext.js"(exports, module) {
    "use strict";
    var React = require_react();
    var ProfilerContext = React.createContext({
      wrapPrepareQueryResource: function wrapPrepareQueryResource(cb) {
        return cb();
      }
    });
    module.exports = ProfilerContext;
  }
});

// node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js
var require_useRelayEnvironment = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js"(exports, module) {
    "use strict";
    var ReactRelayContext = require_ReactRelayContext();
    var invariant = require_browser();
    var _require = require_react();
    var useContext = _require.useContext;
    function useRelayEnvironment() {
      var context = useContext(ReactRelayContext);
      !(context != null) ? true ? invariant(false, "useRelayEnvironment: Expected to have found a Relay environment provided by a `RelayEnvironmentProvider` component. This usually means that useRelayEnvironment was used in a component that is not a descendant of a `RelayEnvironmentProvider`. Please make sure a `RelayEnvironmentProvider` has been rendered somewhere as a parent or ancestor of your component.") : invariant(false) : void 0;
      return context.environment;
    }
    module.exports = useRelayEnvironment;
  }
});

// node_modules/react-relay/lib/relay-hooks/EntryPointContainer.react.js
var require_EntryPointContainer_react = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/EntryPointContainer.react.js"(exports, module) {
    "use strict";
    var ProfilerContext = require_ProfilerContext();
    var useRelayEnvironment = require_useRelayEnvironment();
    var React = require_react();
    var _require = require_react();
    var useContext = _require.useContext;
    var useEffect = _require.useEffect;
    var warning = require_warning();
    function EntryPointContainer(_ref) {
      var entryPointReference = _ref.entryPointReference, props = _ref.props;
      true ? warning(entryPointReference.isDisposed === false, "<EntryPointContainer>: Expected entryPointReference to not be disposed yet. This is because disposing the entrypoint marks it for future garbage collection, and as such may no longer be present in the Relay store. In the future, this will become a hard error.") : void 0;
      var getComponent = entryPointReference.getComponent, queries = entryPointReference.queries, entryPoints = entryPointReference.entryPoints, extraProps = entryPointReference.extraProps, rootModuleID = entryPointReference.rootModuleID;
      var Component = getComponent();
      var profilerContext = useContext(ProfilerContext);
      var environment = useRelayEnvironment();
      useEffect(function() {
        environment.__log({
          name: "entrypoint.root.consume",
          profilerContext,
          rootModuleID
        });
      }, [environment, profilerContext, rootModuleID]);
      return React.createElement(Component, {
        entryPoints,
        extraProps,
        props,
        queries
      });
    }
    module.exports = EntryPointContainer;
  }
});

// node_modules/react-relay/lib/relay-hooks/loadQuery.js
var require_loadQuery = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/loadQuery.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var invariant = require_browser();
    var React = require_react();
    var _require = require_relay_runtime();
    var fetchQueryDeduped = _require.__internal.fetchQueryDeduped;
    var Observable = _require.Observable;
    var PreloadableQueryRegistry = _require.PreloadableQueryRegistry;
    var RelayFeatureFlags = _require.RelayFeatureFlags;
    var ReplaySubject = _require.ReplaySubject;
    var createOperationDescriptor = _require.createOperationDescriptor;
    var getRequest = _require.getRequest;
    var getRequestIdentifier = _require.getRequestIdentifier;
    var warning = require_warning();
    var RenderDispatcher = null;
    var fetchKey = 100001;
    function useTrackLoadQueryInRender() {
      if (RenderDispatcher === null) {
        var _React$__SECRET_INTER, _React$__SECRET_INTER2;
        RenderDispatcher = (_React$__SECRET_INTER = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER === void 0 ? void 0 : (_React$__SECRET_INTER2 = _React$__SECRET_INTER.ReactCurrentDispatcher) === null || _React$__SECRET_INTER2 === void 0 ? void 0 : _React$__SECRET_INTER2.current;
      }
    }
    function loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {
      var _React$__SECRET_INTER3, _React$__SECRET_INTER4, _options$__nameForWar, _options$fetchPolicy;
      var CurrentDispatcher = (_React$__SECRET_INTER3 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER3 === void 0 ? void 0 : (_React$__SECRET_INTER4 = _React$__SECRET_INTER3.ReactCurrentDispatcher) === null || _React$__SECRET_INTER4 === void 0 ? void 0 : _React$__SECRET_INTER4.current;
      true ? warning(RenderDispatcher == null || CurrentDispatcher !== RenderDispatcher, "Relay: `%s` should not be called inside a React render function.", (_options$__nameForWar = options === null || options === void 0 ? void 0 : options.__nameForWarning) !== null && _options$__nameForWar !== void 0 ? _options$__nameForWar : "loadQuery") : void 0;
      fetchKey++;
      var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : "store-or-network";
      var networkCacheConfig = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {
        force: true
      });
      var retainReference;
      var didExecuteNetworkSource = false;
      var executeWithNetworkSource = function executeWithNetworkSource2(operation, networkObservable2) {
        didExecuteNetworkSource = true;
        return environment.executeWithSource({
          operation,
          source: networkObservable2
        });
      };
      var executionSubject = new ReplaySubject();
      var returnedObservable = Observable.create(function(sink) {
        return executionSubject.subscribe(sink);
      });
      var unsubscribeFromNetworkRequest;
      var networkError = null;
      var didMakeNetworkRequest = false;
      var makeNetworkRequest = function makeNetworkRequest2(params2) {
        didMakeNetworkRequest = true;
        var observable;
        var subject = new ReplaySubject();
        if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {
          var identifier = "raw-network-request-" + getRequestIdentifier(params2, variables);
          observable = fetchQueryDeduped(environment, identifier, function() {
            var network2 = environment.getNetwork();
            return network2.execute(params2, variables, networkCacheConfig);
          });
        } else {
          var network = environment.getNetwork();
          observable = network.execute(params2, variables, networkCacheConfig);
        }
        var _observable$subscribe = observable.subscribe({
          error: function error(err) {
            networkError = err;
            subject.error(err);
          },
          next: function next(data) {
            subject.next(data);
          },
          complete: function complete() {
            subject.complete();
          }
        }), unsubscribe = _observable$subscribe.unsubscribe;
        unsubscribeFromNetworkRequest = unsubscribe;
        return Observable.create(function(sink) {
          var subjectSubscription = subject.subscribe(sink);
          return function() {
            subjectSubscription.unsubscribe();
            unsubscribeFromNetworkRequest();
          };
        });
      };
      var unsubscribeFromExecution;
      var executeDeduped = function executeDeduped2(operation, fetchFn) {
        if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {
          didMakeNetworkRequest = true;
        }
        var _fetchQueryDeduped$su = fetchQueryDeduped(environment, operation.request.identifier, fetchFn).subscribe({
          error: function error(err) {
            executionSubject.error(err);
          },
          next: function next(data) {
            executionSubject.next(data);
          },
          complete: function complete() {
            executionSubject.complete();
          }
        });
        unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;
      };
      var checkAvailabilityAndExecute = function checkAvailabilityAndExecute2(concreteRequest) {
        var operation = createOperationDescriptor(concreteRequest, variables, networkCacheConfig);
        retainReference = environment.retain(operation);
        if (fetchPolicy === "store-only") {
          return;
        }
        var shouldFetch = fetchPolicy !== "store-or-network" || environment.check(operation).status !== "available";
        if (shouldFetch) {
          executeDeduped(operation, function() {
            var networkObservable2 = makeNetworkRequest(concreteRequest.params);
            var executeObservable = executeWithNetworkSource(operation, networkObservable2);
            return executeObservable;
          });
        }
      };
      var params;
      var cancelOnLoadCallback;
      var queryId;
      if (preloadableRequest.kind === "PreloadableConcreteRequest") {
        var preloadableConcreteRequest = preloadableRequest;
        params = preloadableConcreteRequest.params;
        var _params = params;
        queryId = _params.id;
        !(queryId !== null) ? true ? invariant(false, "Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id", params.name) : invariant(false) : void 0;
        var _module = PreloadableQueryRegistry.get(queryId);
        if (_module != null) {
          checkAvailabilityAndExecute(_module);
        } else {
          var networkObservable = fetchPolicy === "store-only" ? null : makeNetworkRequest(params);
          var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad(queryId, function(preloadedModule) {
            cancelOnLoadCallback();
            var operation = createOperationDescriptor(preloadedModule, variables, networkCacheConfig);
            retainReference = environment.retain(operation);
            if (networkObservable != null) {
              executeDeduped(operation, function() {
                return executeWithNetworkSource(operation, networkObservable);
              });
            }
          });
          cancelOnLoadCallback = _PreloadableQueryRegi.dispose;
        }
      } else {
        var graphQlTaggedNode = preloadableRequest;
        var request = getRequest(graphQlTaggedNode);
        params = request.params;
        queryId = params.cacheID != null ? params.cacheID : params.id;
        checkAvailabilityAndExecute(request);
      }
      var isDisposed = false;
      var isReleased = false;
      var isNetworkRequestCancelled = false;
      var releaseQuery = function releaseQuery2() {
        if (isReleased) {
          return;
        }
        retainReference && retainReference.dispose();
        isReleased = true;
      };
      var cancelNetworkRequest = function cancelNetworkRequest2() {
        if (isNetworkRequestCancelled) {
          return;
        }
        if (didExecuteNetworkSource) {
          unsubscribeFromExecution && unsubscribeFromExecution();
        } else {
          unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();
        }
        cancelOnLoadCallback && cancelOnLoadCallback();
        isNetworkRequestCancelled = true;
      };
      return {
        kind: "PreloadedQuery",
        environment,
        environmentProviderOptions,
        dispose: function dispose() {
          if (isDisposed) {
            return;
          }
          releaseQuery();
          cancelNetworkRequest();
          isDisposed = true;
        },
        releaseQuery,
        cancelNetworkRequest,
        fetchKey,
        id: queryId,
        get isDisposed() {
          return isDisposed || isReleased;
        },
        get networkError() {
          return networkError;
        },
        name: params.name,
        networkCacheConfig,
        fetchPolicy,
        source: didMakeNetworkRequest ? returnedObservable : void 0,
        variables
      };
    }
    module.exports = {
      loadQuery,
      useTrackLoadQueryInRender
    };
  }
});

// node_modules/react-relay/lib/relay-hooks/loadEntryPoint.js
var require_loadEntryPoint = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/loadEntryPoint.js"(exports, module) {
    "use strict";
    var _require = require_loadQuery();
    var loadQuery = _require.loadQuery;
    function loadEntryPoint(environmentProvider, entryPoint, entryPointParams) {
      var loadingPromise = null;
      if (entryPoint.root.getModuleIfRequired() == null) {
        loadingPromise = entryPoint.root.load();
      }
      var preloadProps = entryPoint.getPreloadProps(entryPointParams);
      var queries = preloadProps.queries, entryPoints = preloadProps.entryPoints, extraProps = preloadProps.extraProps;
      var preloadedQueries = {};
      var preloadedEntryPoints = {};
      if (queries != null) {
        var queriesPropNames = Object.keys(queries);
        queriesPropNames.forEach(function(queryPropName) {
          var _queries$queryPropNam = queries[queryPropName], environmentProviderOptions = _queries$queryPropNam.environmentProviderOptions, options = _queries$queryPropNam.options, parameters = _queries$queryPropNam.parameters, variables = _queries$queryPropNam.variables;
          var environment = environmentProvider.getEnvironment(environmentProviderOptions);
          preloadedQueries[queryPropName] = loadQuery(environment, parameters, variables, {
            fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
            networkCacheConfig: options === null || options === void 0 ? void 0 : options.networkCacheConfig,
            __nameForWarning: "loadEntryPoint"
          }, environmentProviderOptions);
        });
      }
      if (entryPoints != null) {
        var entryPointPropNames = Object.keys(entryPoints);
        entryPointPropNames.forEach(function(entryPointPropName) {
          var entryPointDescription = entryPoints[entryPointPropName];
          if (entryPointDescription == null) {
            return;
          }
          var nestedEntryPoint = entryPointDescription.entryPoint, nestedParams = entryPointDescription.entryPointParams;
          preloadedEntryPoints[entryPointPropName] = loadEntryPoint(environmentProvider, nestedEntryPoint, nestedParams);
        });
      }
      var isDisposed = false;
      return {
        dispose: function dispose() {
          if (isDisposed) {
            return;
          }
          if (preloadedQueries != null) {
            Object.values(preloadedQueries).forEach(function(_ref) {
              var innerDispose = _ref.dispose;
              innerDispose();
            });
          }
          if (preloadedEntryPoints != null) {
            Object.values(preloadedEntryPoints).forEach(function(_ref2) {
              var innerDispose = _ref2.dispose;
              innerDispose();
            });
          }
          isDisposed = true;
        },
        entryPoints: preloadedEntryPoints,
        extraProps: extraProps !== null && extraProps !== void 0 ? extraProps : null,
        getComponent: function getComponent() {
          var componentModule = entryPoint.root.getModuleIfRequired();
          if (componentModule == null) {
            var _loadingPromise;
            loadingPromise = (_loadingPromise = loadingPromise) !== null && _loadingPromise !== void 0 ? _loadingPromise : entryPoint.root.load();
            throw loadingPromise;
          }
          var component = componentModule["default"] != null ? componentModule["default"] : componentModule;
          return component;
        },
        get isDisposed() {
          return isDisposed;
        },
        queries: preloadedQueries,
        rootModuleID: entryPoint.root.getModuleId()
      };
    }
    module.exports = loadEntryPoint;
  }
});

// node_modules/react-relay/lib/relay-hooks/RelayEnvironmentProvider.js
var require_RelayEnvironmentProvider = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/RelayEnvironmentProvider.js"(exports, module) {
    "use strict";
    var ReactRelayContext = require_ReactRelayContext();
    var React = require_react();
    var useMemo = React.useMemo;
    function RelayEnvironmentProvider(props) {
      var children = props.children, environment = props.environment, getEnvironmentForActor = props.getEnvironmentForActor;
      var context = useMemo(function() {
        return {
          environment,
          getEnvironmentForActor
        };
      }, [environment, getEnvironmentForActor]);
      return React.createElement(ReactRelayContext.Provider, {
        value: context
      }, children);
    }
    module.exports = RelayEnvironmentProvider;
  }
});

// node_modules/react-relay/lib/relay-hooks/HooksImplementation.js
var require_HooksImplementation = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/HooksImplementation.js"(exports, module) {
    "use strict";
    var warning = require_warning();
    var implementation = null;
    function inject(impl) {
      true ? warning(implementation === null, "Relay HooksImplementation was injected twice.") : void 0;
      implementation = impl;
    }
    function get() {
      return implementation;
    }
    module.exports = {
      inject,
      get
    };
  }
});

// node_modules/react-relay/lib/relay-hooks/useUnsafeRef_DEPRECATED.js
var require_useUnsafeRef_DEPRECATED = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useUnsafeRef_DEPRECATED.js"(exports, module) {
    "use strict";
    var _require = require_react();
    var useMemo = _require.useMemo;
    function useUnsafeRef_DEPRECATED(init) {
      return useMemo(function() {
        return {
          current: init
        };
      }, []);
    }
    module.exports = useUnsafeRef_DEPRECATED;
  }
});

// node_modules/react-relay/lib/relay-hooks/LRUCache.js
var require_LRUCache = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/LRUCache.js"(exports, module) {
    "use strict";
    var invariant = require_browser();
    var LRUCache = function() {
      function LRUCache2(capacity) {
        this._capacity = capacity;
        !(this._capacity > 0) ? true ? invariant(false, "LRUCache: Unable to create instance of cache with zero or negative capacity.") : invariant(false) : void 0;
        this._map = /* @__PURE__ */ new Map();
      }
      var _proto = LRUCache2.prototype;
      _proto.set = function set(key, value) {
        this._map["delete"](key);
        this._map.set(key, value);
        if (this._map.size > this._capacity) {
          var firstKey = this._map.keys().next();
          if (!firstKey.done) {
            this._map["delete"](firstKey.value);
          }
        }
      };
      _proto.get = function get(key) {
        var value = this._map.get(key);
        if (value != null) {
          this._map["delete"](key);
          this._map.set(key, value);
        }
        return value;
      };
      _proto.has = function has(key) {
        return this._map.has(key);
      };
      _proto["delete"] = function _delete(key) {
        this._map["delete"](key);
      };
      _proto.size = function size() {
        return this._map.size;
      };
      _proto.capacity = function capacity() {
        return this._capacity - this._map.size;
      };
      _proto.clear = function clear() {
        this._map.clear();
      };
      return LRUCache2;
    }();
    function create(capacity) {
      return new LRUCache(capacity);
    }
    module.exports = {
      create
    };
  }
});

// node_modules/react-relay/lib/relay-hooks/SuspenseResource.js
var require_SuspenseResource = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/SuspenseResource.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var warning = require_warning();
    var TEMPORARY_RETAIN_DURATION_MS = 5 * 60 * 1e3;
    var SuspenseResource = function() {
      function SuspenseResource2(retain) {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_retainCount", 0);
        (0, _defineProperty2["default"])(this, "_retainDisposable", null);
        (0, _defineProperty2["default"])(this, "_releaseTemporaryRetain", null);
        this._retain = function(environment) {
          _this._retainCount++;
          if (_this._retainCount === 1) {
            _this._retainDisposable = retain(environment);
          }
          return {
            dispose: function dispose() {
              _this._retainCount = Math.max(0, _this._retainCount - 1);
              if (_this._retainCount === 0) {
                if (_this._retainDisposable != null) {
                  _this._retainDisposable.dispose();
                  _this._retainDisposable = null;
                } else {
                  true ? warning(false, "Relay: Expected disposable to release query to be defined.If you're seeing this, this is likely a bug in Relay.") : void 0;
                }
              }
            }
          };
        };
      }
      var _proto = SuspenseResource2.prototype;
      _proto.temporaryRetain = function temporaryRetain(environment) {
        var _this2 = this;
        var _this$_releaseTempora;
        if (environment.isServer()) {
          return {
            dispose: function dispose() {
            }
          };
        }
        var retention = this._retain(environment);
        var releaseQueryTimeout = null;
        var releaseTemporaryRetain = function releaseTemporaryRetain2() {
          clearTimeout(releaseQueryTimeout);
          releaseQueryTimeout = null;
          _this2._releaseTemporaryRetain = null;
          retention.dispose();
        };
        releaseQueryTimeout = setTimeout(releaseTemporaryRetain, TEMPORARY_RETAIN_DURATION_MS);
        (_this$_releaseTempora = this._releaseTemporaryRetain) === null || _this$_releaseTempora === void 0 ? void 0 : _this$_releaseTempora.call(this);
        this._releaseTemporaryRetain = releaseTemporaryRetain;
        return {
          dispose: function dispose() {
            var _this$_releaseTempora2;
            (_this$_releaseTempora2 = _this2._releaseTemporaryRetain) === null || _this$_releaseTempora2 === void 0 ? void 0 : _this$_releaseTempora2.call(_this2);
          }
        };
      };
      _proto.permanentRetain = function permanentRetain(environment) {
        var disposable = this._retain(environment);
        this.releaseTemporaryRetain();
        return disposable;
      };
      _proto.releaseTemporaryRetain = function releaseTemporaryRetain() {
        var _this$_releaseTempora3;
        (_this$_releaseTempora3 = this._releaseTemporaryRetain) === null || _this$_releaseTempora3 === void 0 ? void 0 : _this$_releaseTempora3.call(this);
        this._releaseTemporaryRetain = null;
      };
      _proto.getRetainCount = function getRetainCount() {
        return this._retainCount;
      };
      return SuspenseResource2;
    }();
    module.exports = SuspenseResource;
  }
});

// node_modules/react-relay/lib/relay-hooks/QueryResource.js
var require_QueryResource = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/QueryResource.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var LRUCache = require_LRUCache();
    var SuspenseResource = require_SuspenseResource();
    var invariant = require_browser();
    var _require = require_relay_runtime();
    var isPromise = _require.isPromise;
    var warning = require_warning();
    var CACHE_CAPACITY = 1e3;
    var DEFAULT_FETCH_POLICY = "store-or-network";
    var DEFAULT_LIVE_FETCH_POLICY = "store-and-network";
    var WEAKMAP_SUPPORTED = typeof WeakMap === "function";
    function operationIsLiveQuery(operation) {
      return operation.request.node.params.metadata.live !== void 0;
    }
    function getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {
      var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : operationIsLiveQuery(operation) ? DEFAULT_LIVE_FETCH_POLICY : DEFAULT_FETCH_POLICY;
      var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();
      var cacheIdentifier = "".concat(fetchPolicy, "-").concat(renderPolicy, "-").concat(operation.request.identifier);
      if (cacheBreaker != null) {
        return "".concat(cacheIdentifier, "-").concat(cacheBreaker);
      }
      return cacheIdentifier;
    }
    function getQueryResult(operation, cacheIdentifier) {
      var rootFragmentRef = {
        __id: operation.fragment.dataID,
        __fragments: (0, _defineProperty2["default"])({}, operation.fragment.node.name, operation.request.variables),
        __fragmentOwner: operation.request
      };
      return {
        cacheIdentifier,
        fragmentNode: operation.request.node.fragment,
        fragmentRef: rootFragmentRef,
        operation
      };
    }
    var nextID = 2e5;
    function createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {
      var isLiveQuery = operationIsLiveQuery(operation);
      var currentValue = value;
      var currentNetworkSubscription = networkSubscription;
      var suspenseResource = new SuspenseResource(function(environment) {
        var retention = environment.retain(operation);
        return {
          dispose: function dispose() {
            if (isLiveQuery && currentNetworkSubscription != null) {
              currentNetworkSubscription.unsubscribe();
            }
            retention.dispose();
            onDispose(cacheEntry);
          }
        };
      });
      var cacheEntry = {
        cacheIdentifier,
        id: nextID++,
        processedPayloadsCount: 0,
        operationAvailability,
        getValue: function getValue() {
          return currentValue;
        },
        setValue: function setValue(val) {
          currentValue = val;
        },
        setNetworkSubscription: function setNetworkSubscription(subscription) {
          if (isLiveQuery && currentNetworkSubscription != null) {
            currentNetworkSubscription.unsubscribe();
          }
          currentNetworkSubscription = subscription;
        },
        temporaryRetain: function temporaryRetain(environment) {
          return suspenseResource.temporaryRetain(environment);
        },
        permanentRetain: function permanentRetain(environment) {
          return suspenseResource.permanentRetain(environment);
        },
        releaseTemporaryRetain: function releaseTemporaryRetain() {
          suspenseResource.releaseTemporaryRetain();
        }
      };
      return cacheEntry;
    }
    var QueryResourceImpl = function() {
      function QueryResourceImpl2(environment) {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_clearCacheEntry", function(cacheEntry) {
          _this._cache["delete"](cacheEntry.cacheIdentifier);
        });
        this._environment = environment;
        this._cache = LRUCache.create(CACHE_CAPACITY);
      }
      var _proto = QueryResourceImpl2.prototype;
      _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {
        var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);
        return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);
      };
      _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {
        var environment = this._environment;
        var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : operationIsLiveQuery(operation) ? DEFAULT_LIVE_FETCH_POLICY : DEFAULT_FETCH_POLICY;
        var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();
        var cacheEntry = this._cache.get(cacheIdentifier);
        var temporaryRetainDisposable = null;
        var entryWasCached = cacheEntry != null;
        if (cacheEntry == null) {
          cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
            unsubscribe: function unsubscribe(subscription) {
              if (temporaryRetainDisposable != null) {
                temporaryRetainDisposable.dispose();
              }
              var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;
              observerUnsubscribe && observerUnsubscribe(subscription);
            }
          }));
        }
        temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);
        var cachedValue = cacheEntry.getValue();
        if (isPromise(cachedValue)) {
          environment.__log({
            name: "suspense.query",
            fetchPolicy,
            isPromiseCached: entryWasCached,
            operation,
            queryAvailability: cacheEntry.operationAvailability,
            renderPolicy
          });
          throw cachedValue;
        }
        if (cachedValue instanceof Error) {
          throw cachedValue;
        }
        return cachedValue;
      };
      _proto.retain = function retain(queryResult, profilerContext) {
        var environment = this._environment;
        var cacheIdentifier = queryResult.cacheIdentifier, operation = queryResult.operation;
        var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);
        var disposable = cacheEntry.permanentRetain(environment);
        environment.__log({
          name: "queryresource.retain",
          profilerContext,
          resourceID: cacheEntry.id
        });
        return {
          dispose: function dispose() {
            disposable.dispose();
          }
        };
      };
      _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {
        var cacheEntry = this._cache.get(queryResult.cacheIdentifier);
        if (cacheEntry != null) {
          cacheEntry.releaseTemporaryRetain();
        }
      };
      _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {
        var environment = this._environment;
        var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);
        return this._cache.get(cacheIdentifier);
      };
      _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {
        var cacheEntry = this._cache.get(cacheIdentifier);
        if (cacheEntry == null) {
          cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);
          this._cache.set(cacheIdentifier, cacheEntry);
        }
        return cacheEntry;
      };
      _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {
        var _this2 = this;
        var environment = this._environment;
        var queryAvailability = environment.check(operation);
        var queryStatus = queryAvailability.status;
        var hasFullQuery = queryStatus === "available";
        var canPartialRender = hasFullQuery || renderPolicy === "partial" && queryStatus !== "stale";
        var shouldFetch;
        var shouldAllowRender;
        var resolveNetworkPromise = function resolveNetworkPromise2() {
        };
        switch (fetchPolicy) {
          case "store-only": {
            shouldFetch = false;
            shouldAllowRender = true;
            break;
          }
          case "store-or-network": {
            shouldFetch = !hasFullQuery;
            shouldAllowRender = canPartialRender;
            break;
          }
          case "store-and-network": {
            shouldFetch = true;
            shouldAllowRender = canPartialRender;
            break;
          }
          case "network-only":
          default: {
            shouldFetch = true;
            shouldAllowRender = false;
            break;
          }
        }
        if (shouldAllowRender) {
          var queryResult = getQueryResult(operation, cacheIdentifier);
          var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);
          this._cache.set(cacheIdentifier, _cacheEntry);
        }
        if (shouldFetch) {
          var _queryResult = getQueryResult(operation, cacheIdentifier);
          var networkSubscription;
          fetchObservable.subscribe({
            start: function start(subscription) {
              networkSubscription = subscription;
              var cacheEntry2 = _this2._cache.get(cacheIdentifier);
              if (cacheEntry2) {
                cacheEntry2.setNetworkSubscription(networkSubscription);
              }
              var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;
              if (observerStart) {
                var subscriptionWithConditionalCancelation = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, subscription), {}, {
                  unsubscribe: function unsubscribe() {
                    if (operationIsLiveQuery(operation)) {
                      subscription.unsubscribe();
                    }
                  }
                });
                observerStart(subscriptionWithConditionalCancelation);
              }
            },
            next: function next() {
              var cacheEntry2 = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);
              cacheEntry2.processedPayloadsCount += 1;
              cacheEntry2.setValue(_queryResult);
              resolveNetworkPromise();
              var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;
              if (observerNext != null) {
                var snapshot = environment.lookup(operation.fragment);
                observerNext(snapshot);
              }
            },
            error: function error(_error) {
              var cacheEntry2 = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription);
              if (cacheEntry2.processedPayloadsCount === 0) {
                cacheEntry2.setValue(_error);
              } else {
                true ? warning(false, "QueryResource: An incremental payload for query `%s` returned an error: `%s`.", operation.fragment.node.name, String(_error.message)) : void 0;
              }
              resolveNetworkPromise();
              networkSubscription = null;
              cacheEntry2.setNetworkSubscription(null);
              var observerError = observer === null || observer === void 0 ? void 0 : observer.error;
              observerError && observerError(_error);
            },
            complete: function complete() {
              resolveNetworkPromise();
              networkSubscription = null;
              var cacheEntry2 = _this2._cache.get(cacheIdentifier);
              if (cacheEntry2) {
                cacheEntry2.setNetworkSubscription(null);
              }
              var observerComplete2 = observer === null || observer === void 0 ? void 0 : observer.complete;
              observerComplete2 && observerComplete2();
            },
            unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe
          });
          var _cacheEntry2 = this._cache.get(cacheIdentifier);
          if (!_cacheEntry2) {
            var networkPromise = new Promise(function(resolve) {
              resolveNetworkPromise = resolve;
            });
            networkPromise.displayName = "Relay(" + operation.fragment.node.name + ")";
            _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);
            this._cache.set(cacheIdentifier, _cacheEntry2);
          }
        } else {
          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;
          observerComplete && observerComplete();
        }
        var cacheEntry = this._cache.get(cacheIdentifier);
        !(cacheEntry != null) ? true ? invariant(false, "Relay: Expected to have cached a result when attempting to fetch query.If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
        environment.__log({
          name: "queryresource.fetch",
          resourceID: cacheEntry.id,
          operation,
          profilerContext,
          fetchPolicy,
          renderPolicy,
          queryAvailability,
          shouldFetch
        });
        return cacheEntry;
      };
      return QueryResourceImpl2;
    }();
    function createQueryResource(environment) {
      return new QueryResourceImpl(environment);
    }
    var dataResources = WEAKMAP_SUPPORTED ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map();
    function getQueryResourceForEnvironment(environment) {
      var cached = dataResources.get(environment);
      if (cached) {
        return cached;
      }
      var newDataResource = createQueryResource(environment);
      dataResources.set(environment, newDataResource);
      return newDataResource;
    }
    module.exports = {
      createQueryResource,
      getQueryResourceForEnvironment,
      getQueryCacheIdentifier
    };
  }
});

// node_modules/react-relay/lib/relay-hooks/legacy/FragmentResource.js
var require_FragmentResource = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/legacy/FragmentResource.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var LRUCache = require_LRUCache();
    var _require = require_QueryResource();
    var getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
    var SuspenseResource = require_SuspenseResource();
    var invariant = require_browser();
    var _require2 = require_relay_runtime();
    var _require2$__internal = _require2.__internal;
    var fetchQuery = _require2$__internal.fetchQuery;
    var getPromiseForActiveRequest = _require2$__internal.getPromiseForActiveRequest;
    var RelayFeatureFlags = _require2.RelayFeatureFlags;
    var createOperationDescriptor = _require2.createOperationDescriptor;
    var getFragmentIdentifier = _require2.getFragmentIdentifier;
    var getPendingOperationsForFragment = _require2.getPendingOperationsForFragment;
    var getSelector = _require2.getSelector;
    var getVariablesFromFragment = _require2.getVariablesFromFragment;
    var handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors;
    var isPromise = _require2.isPromise;
    var recycleNodesInto = _require2.recycleNodesInto;
    var WEAKMAP_SUPPORTED = typeof WeakMap === "function";
    var CACHE_CAPACITY = 1e6;
    var CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);
    function isMissingData(snapshot) {
      if (Array.isArray(snapshot)) {
        return snapshot.some(function(s) {
          return s.isMissingData;
        });
      }
      return snapshot.isMissingData;
    }
    function hasMissingClientEdges(snapshot) {
      var _snapshot$missingClie, _snapshot$missingClie2;
      if (Array.isArray(snapshot)) {
        return snapshot.some(function(s) {
          var _s$missingClientEdges, _s$missingClientEdges2;
          return ((_s$missingClientEdges = (_s$missingClientEdges2 = s.missingClientEdges) === null || _s$missingClientEdges2 === void 0 ? void 0 : _s$missingClientEdges2.length) !== null && _s$missingClientEdges !== void 0 ? _s$missingClientEdges : 0) > 0;
        });
      }
      return ((_snapshot$missingClie = (_snapshot$missingClie2 = snapshot.missingClientEdges) === null || _snapshot$missingClie2 === void 0 ? void 0 : _snapshot$missingClie2.length) !== null && _snapshot$missingClie !== void 0 ? _snapshot$missingClie : 0) > 0;
    }
    function missingLiveResolverFields(snapshot) {
      if (Array.isArray(snapshot)) {
        return snapshot.map(function(s) {
          return s.missingLiveResolverFields;
        }).filter(Boolean).flat();
      }
      return snapshot.missingLiveResolverFields;
    }
    function singularOrPluralForEach(snapshot, f) {
      if (Array.isArray(snapshot)) {
        snapshot.forEach(f);
      } else {
        f(snapshot);
      }
    }
    function getFragmentResult(cacheKey, snapshot, storeEpoch) {
      if (Array.isArray(snapshot)) {
        return {
          cacheKey,
          snapshot,
          data: snapshot.map(function(s) {
            return s.data;
          }),
          isMissingData: isMissingData(snapshot),
          storeEpoch
        };
      }
      return {
        cacheKey,
        snapshot,
        data: snapshot.data,
        isMissingData: isMissingData(snapshot),
        storeEpoch
      };
    }
    var ClientEdgeQueryResultsCache = function() {
      function ClientEdgeQueryResultsCache2(environment) {
        (0, _defineProperty2["default"])(this, "_cache", /* @__PURE__ */ new Map());
        (0, _defineProperty2["default"])(this, "_retainCounts", /* @__PURE__ */ new Map());
        this._environment = environment;
      }
      var _proto = ClientEdgeQueryResultsCache2.prototype;
      _proto.get = function get(fragmentIdentifier) {
        var _this$_cache$get$, _this$_cache$get;
        return (_this$_cache$get$ = (_this$_cache$get = this._cache.get(fragmentIdentifier)) === null || _this$_cache$get === void 0 ? void 0 : _this$_cache$get[0]) !== null && _this$_cache$get$ !== void 0 ? _this$_cache$get$ : void 0;
      };
      _proto.recordQueryResults = function recordQueryResults(fragmentIdentifier, value) {
        var _this = this;
        var existing = this._cache.get(fragmentIdentifier);
        if (!existing) {
          var suspenseResource = new SuspenseResource(function() {
            return _this._retain(fragmentIdentifier);
          });
          this._cache.set(fragmentIdentifier, [value, suspenseResource]);
          suspenseResource.temporaryRetain(this._environment);
        } else {
          var existingResults = existing[0], _suspenseResource = existing[1];
          value.forEach(function(queryResult) {
            existingResults.push(queryResult);
          });
          _suspenseResource.temporaryRetain(this._environment);
        }
      };
      _proto._retain = function _retain(id) {
        var _this2 = this;
        var _this$_retainCounts$g;
        var retainCount = ((_this$_retainCounts$g = this._retainCounts.get(id)) !== null && _this$_retainCounts$g !== void 0 ? _this$_retainCounts$g : 0) + 1;
        this._retainCounts.set(id, retainCount);
        return {
          dispose: function dispose() {
            var _this$_retainCounts$g2;
            var newRetainCount = ((_this$_retainCounts$g2 = _this2._retainCounts.get(id)) !== null && _this$_retainCounts$g2 !== void 0 ? _this$_retainCounts$g2 : 0) - 1;
            if (newRetainCount > 0) {
              _this2._retainCounts.set(id, newRetainCount);
            } else {
              _this2._retainCounts["delete"](id);
              _this2._cache["delete"](id);
            }
          }
        };
      };
      return ClientEdgeQueryResultsCache2;
    }();
    var FragmentResourceImpl = function() {
      function FragmentResourceImpl2(environment) {
        this._environment = environment;
        this._cache = LRUCache.create(CACHE_CAPACITY);
        if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {
          this._clientEdgeQueryResultsCache = new ClientEdgeQueryResultsCache(environment);
        }
      }
      var _proto2 = FragmentResourceImpl2.prototype;
      _proto2.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {
        return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);
      };
      _proto2.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {
        var _this3 = this;
        var _fragmentNode$metadat, _fragmentNode$metadat2, _missingLiveResolverF2, _missingLiveResolverF3;
        var environment = this._environment;
        if (fragmentRef == null) {
          return {
            cacheKey: fragmentIdentifier,
            data: null,
            isMissingData: false,
            snapshot: null,
            storeEpoch: 0
          };
        }
        var storeEpoch = environment.getStore().getEpoch();
        if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {
          !Array.isArray(fragmentRef) ? true ? invariant(false, "Relay: Expected fragment pointer%s for fragment `%s` to be an array, instead got `%s`. Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.", fragmentKey != null ? " for key `".concat(fragmentKey, "`") : "", fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;
          if (fragmentRef.length === 0) {
            return {
              cacheKey: fragmentIdentifier,
              data: CONSTANT_READONLY_EMPTY_ARRAY,
              isMissingData: false,
              snapshot: CONSTANT_READONLY_EMPTY_ARRAY,
              storeEpoch
            };
          }
        }
        var cachedValue = this._cache.get(fragmentIdentifier);
        if (cachedValue != null) {
          var _missingLiveResolverF;
          if (cachedValue.kind === "pending" && isPromise(cachedValue.promise)) {
            environment.__log({
              name: "suspense.fragment",
              data: cachedValue.result.data,
              fragment: fragmentNode,
              isRelayHooks: true,
              isMissingData: cachedValue.result.isMissingData,
              isPromiseCached: true,
              pendingOperations: cachedValue.pendingOperations
            });
            throw cachedValue.promise;
          }
          if (cachedValue.kind === "done" && cachedValue.result.snapshot && !((_missingLiveResolverF = missingLiveResolverFields(cachedValue.result.snapshot)) !== null && _missingLiveResolverF !== void 0 && _missingLiveResolverF.length)) {
            this._throwOrLogErrorsInSnapshot(cachedValue.result.snapshot);
            if (cachedValue.result.isMissingData) {
              environment.__log({
                name: "fragmentresource.missing_data",
                data: cachedValue.result.data,
                fragment: fragmentNode,
                isRelayHooks: true,
                cached: true
              });
            }
            return cachedValue.result;
          }
        }
        var fragmentSelector = getSelector(fragmentNode, fragmentRef);
        !(fragmentSelector != null) ? true ? invariant(false, "Relay: Expected to receive an object where `...%s` was spread, but the fragment reference was not found`. This is most likely the result of:\n- Forgetting to spread `%s` in `%s`'s parent's fragment.\n- Conditionally fetching `%s` but unconditionally passing %s prop to `%s`. If the parent fragment only fetches the fragment conditionally - with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` spread  - then the fragment reference will not exist. In this case, pass `null` if the conditions for evaluating the fragment are not met (e.g. if the `@include(if)` value is false.)", fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? "a fragment reference" : "the `".concat(fragmentKey, "`"), componentDisplayName) : invariant(false) : void 0;
        var fragmentResult = null;
        var snapshot = null;
        if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE && cachedValue != null && cachedValue.kind === "missing") {
          fragmentResult = cachedValue.result;
          snapshot = cachedValue.snapshot;
        } else {
          snapshot = fragmentSelector.kind === "PluralReaderSelector" ? fragmentSelector.selectors.map(function(s) {
            return environment.lookup(s);
          }) : environment.lookup(fragmentSelector);
          fragmentResult = getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);
        }
        if (!fragmentResult.isMissingData) {
          this._throwOrLogErrorsInSnapshot(snapshot);
          this._cache.set(fragmentIdentifier, {
            kind: "done",
            result: fragmentResult
          });
          return fragmentResult;
        }
        var clientEdgeRequests = null;
        if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && ((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true && hasMissingClientEdges(snapshot)) {
          clientEdgeRequests = [];
          var queryResource = getQueryResourceForEnvironment(this._environment);
          var queryResults = [];
          singularOrPluralForEach(snapshot, function(snap) {
            var _snap$missingClientEd;
            (_snap$missingClientEd = snap.missingClientEdges) === null || _snap$missingClientEd === void 0 ? void 0 : _snap$missingClientEd.forEach(function(_ref) {
              var _clientEdgeRequests;
              var request = _ref.request, clientEdgeDestinationID = _ref.clientEdgeDestinationID;
              var _this3$_performClient = _this3._performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID), queryResult = _this3$_performClient.queryResult, requestDescriptor = _this3$_performClient.requestDescriptor;
              queryResults.push(queryResult);
              (_clientEdgeRequests = clientEdgeRequests) === null || _clientEdgeRequests === void 0 ? void 0 : _clientEdgeRequests.push(requestDescriptor);
            });
          });
          !(this._clientEdgeQueryResultsCache != null) ? true ? invariant(false, "Client edge query result cache should exist when ENABLE_CLIENT_EDGES is on.") : invariant(false) : void 0;
          this._clientEdgeQueryResultsCache.recordQueryResults(fragmentIdentifier, queryResults);
        }
        var clientEdgePromises = [];
        if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && clientEdgeRequests) {
          clientEdgePromises = clientEdgeRequests.map(function(request) {
            return getPromiseForActiveRequest(_this3._environment, request);
          }).filter(Boolean);
        }
        var fragmentOwner = fragmentSelector.kind === "PluralReaderSelector" ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;
        var parentQueryPromiseResult = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner, fragmentResult);
        var parentQueryPromiseResultPromise = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.promise;
        var missingResolverFieldPromises = (_missingLiveResolverF2 = (_missingLiveResolverF3 = missingLiveResolverFields(snapshot)) === null || _missingLiveResolverF3 === void 0 ? void 0 : _missingLiveResolverF3.map(function(_ref2) {
          var liveStateID = _ref2.liveStateID;
          var store = environment.getStore();
          return store.getLiveResolverPromise(liveStateID);
        })) !== null && _missingLiveResolverF2 !== void 0 ? _missingLiveResolverF2 : [];
        if (clientEdgePromises.length || missingResolverFieldPromises.length || isPromise(parentQueryPromiseResultPromise)) {
          var _parentQueryPromiseRe, _clientEdgeRequests2;
          environment.__log({
            name: "suspense.fragment",
            data: fragmentResult.data,
            fragment: fragmentNode,
            isRelayHooks: true,
            isPromiseCached: false,
            isMissingData: fragmentResult.isMissingData,
            pendingOperations: [].concat((0, _toConsumableArray2["default"])((_parentQueryPromiseRe = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.pendingOperations) !== null && _parentQueryPromiseRe !== void 0 ? _parentQueryPromiseRe : []), (0, _toConsumableArray2["default"])((_clientEdgeRequests2 = clientEdgeRequests) !== null && _clientEdgeRequests2 !== void 0 ? _clientEdgeRequests2 : []))
          });
          var promises = [];
          if (clientEdgePromises.length > 0) {
            promises = promises.concat(clientEdgePromises);
          }
          if (missingResolverFieldPromises.length > 0) {
            promises = promises.concat(missingResolverFieldPromises);
          }
          if (promises.length > 0) {
            if (parentQueryPromiseResultPromise) {
              promises.push(parentQueryPromiseResultPromise);
            }
            throw Promise.all(promises);
          }
          if (parentQueryPromiseResultPromise) {
            throw parentQueryPromiseResultPromise;
          }
        }
        if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE && fragmentResult.isMissingData) {
          this._cache.set(fragmentIdentifier, {
            kind: "done",
            result: fragmentResult
          });
        }
        this._throwOrLogErrorsInSnapshot(snapshot);
        environment.__log({
          name: "fragmentresource.missing_data",
          data: fragmentResult.data,
          fragment: fragmentNode,
          isRelayHooks: true,
          cached: false
        });
        return getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);
      };
      _proto2._performClientEdgeQuery = function _performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID) {
        var originalVariables = getVariablesFromFragment(fragmentNode, fragmentRef);
        var variables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, originalVariables), {}, {
          id: clientEdgeDestinationID
        });
        var operation = createOperationDescriptor(request, variables, {});
        var fetchObservable = fetchQuery(this._environment, operation);
        var queryResult = queryResource.prepare(operation, fetchObservable);
        return {
          requestDescriptor: operation.request,
          queryResult
        };
      };
      _proto2._throwOrLogErrorsInSnapshot = function _throwOrLogErrorsInSnapshot(snapshot) {
        var _this4 = this;
        if (Array.isArray(snapshot)) {
          snapshot.forEach(function(s) {
            handlePotentialSnapshotErrors(_this4._environment, s.missingRequiredFields, s.relayResolverErrors, s.errorResponseFields);
          });
        } else {
          handlePotentialSnapshotErrors(this._environment, snapshot.missingRequiredFields, snapshot.relayResolverErrors, snapshot.errorResponseFields);
        }
      };
      _proto2.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {
        var result = {};
        for (var key in fragmentNodes) {
          result[key] = this.read(fragmentNodes[key], fragmentRefs[key], componentDisplayName, key);
        }
        return result;
      };
      _proto2.subscribe = function subscribe(fragmentResult, callback) {
        var _this5 = this;
        var environment = this._environment;
        var cacheKey = fragmentResult.cacheKey;
        var renderedSnapshot = fragmentResult.snapshot;
        if (!renderedSnapshot) {
          return {
            dispose: function dispose() {
            }
          };
        }
        var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult), didMissUpdates = _this$checkMissedUpda[0], currentSnapshot = _this$checkMissedUpda[1];
        if (didMissUpdates) {
          callback();
        }
        var disposables = [];
        if (Array.isArray(renderedSnapshot)) {
          !Array.isArray(currentSnapshot) ? true ? invariant(false, "Relay: Expected snapshots to be plural. If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
          currentSnapshot.forEach(function(snapshot, idx) {
            disposables.push(environment.subscribe(snapshot, function(latestSnapshot) {
              var storeEpoch = environment.getStore().getEpoch();
              _this5._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx, storeEpoch);
              callback();
            }));
          });
        } else {
          !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? true ? invariant(false, "Relay: Expected snapshot to be singular. If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
          disposables.push(environment.subscribe(currentSnapshot, function(latestSnapshot) {
            var storeEpoch = environment.getStore().getEpoch();
            var result = getFragmentResult(cacheKey, latestSnapshot, storeEpoch);
            if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE && result.isMissingData) {
              _this5._cache.set(cacheKey, {
                kind: "missing",
                result,
                snapshot: latestSnapshot
              });
            } else {
              _this5._cache.set(cacheKey, {
                kind: "done",
                result: getFragmentResult(cacheKey, latestSnapshot, storeEpoch)
              });
            }
            callback();
          }));
        }
        if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {
          var _this$_clientEdgeQuer, _this$_clientEdgeQuer2;
          var clientEdgeQueryResults = (_this$_clientEdgeQuer = (_this$_clientEdgeQuer2 = this._clientEdgeQueryResultsCache) === null || _this$_clientEdgeQuer2 === void 0 ? void 0 : _this$_clientEdgeQuer2.get(cacheKey)) !== null && _this$_clientEdgeQuer !== void 0 ? _this$_clientEdgeQuer : void 0;
          if (clientEdgeQueryResults !== null && clientEdgeQueryResults !== void 0 && clientEdgeQueryResults.length) {
            var queryResource = getQueryResourceForEnvironment(this._environment);
            clientEdgeQueryResults.forEach(function(queryResult) {
              disposables.push(queryResource.retain(queryResult));
            });
          }
        }
        return {
          dispose: function dispose() {
            disposables.forEach(function(s) {
              return s.dispose();
            });
            _this5._cache["delete"](cacheKey);
          }
        };
      };
      _proto2.subscribeSpec = function subscribeSpec(fragmentResults, callback) {
        var _this6 = this;
        var disposables = Object.keys(fragmentResults).map(function(key) {
          return _this6.subscribe(fragmentResults[key], callback);
        });
        return {
          dispose: function dispose() {
            disposables.forEach(function(disposable) {
              disposable.dispose();
            });
          }
        };
      };
      _proto2.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {
        var environment = this._environment;
        var renderedSnapshot = fragmentResult.snapshot;
        if (!renderedSnapshot) {
          return [false, null];
        }
        var storeEpoch = null;
        storeEpoch = environment.getStore().getEpoch();
        if (fragmentResult.storeEpoch === storeEpoch) {
          return [false, fragmentResult.snapshot];
        }
        var cacheKey = fragmentResult.cacheKey;
        if (Array.isArray(renderedSnapshot)) {
          var didMissUpdates = false;
          var currentSnapshots = [];
          renderedSnapshot.forEach(function(snapshot, idx) {
            var currentSnapshot2 = environment.lookup(snapshot.selector);
            var renderData2 = snapshot.data;
            var currentData2 = currentSnapshot2.data;
            var updatedData2 = recycleNodesInto(renderData2, currentData2);
            if (updatedData2 !== renderData2) {
              currentSnapshot2 = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, currentSnapshot2), {}, {
                data: updatedData2
              });
              didMissUpdates = true;
            }
            currentSnapshots[idx] = currentSnapshot2;
          });
          if (didMissUpdates) {
            var result = getFragmentResult(cacheKey, currentSnapshots, storeEpoch);
            if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE && result.isMissingData) {
              this._cache.set(cacheKey, {
                kind: "missing",
                result,
                snapshot: currentSnapshots
              });
            } else {
              this._cache.set(cacheKey, {
                kind: "done",
                result
              });
            }
          }
          return [didMissUpdates, currentSnapshots];
        }
        var currentSnapshot = environment.lookup(renderedSnapshot.selector);
        var renderData = renderedSnapshot.data;
        var currentData = currentSnapshot.data;
        var updatedData = recycleNodesInto(renderData, currentData);
        var updatedCurrentSnapshot = {
          data: updatedData,
          isMissingData: currentSnapshot.isMissingData,
          missingClientEdges: currentSnapshot.missingClientEdges,
          missingLiveResolverFields: currentSnapshot.missingLiveResolverFields,
          seenRecords: currentSnapshot.seenRecords,
          selector: currentSnapshot.selector,
          missingRequiredFields: currentSnapshot.missingRequiredFields,
          relayResolverErrors: currentSnapshot.relayResolverErrors,
          errorResponseFields: currentSnapshot.errorResponseFields
        };
        if (updatedData !== renderData) {
          var _result = getFragmentResult(cacheKey, updatedCurrentSnapshot, storeEpoch);
          if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE && _result.isMissingData) {
            this._cache.set(cacheKey, {
              kind: "missing",
              result: _result,
              snapshot: updatedCurrentSnapshot
            });
          } else {
            this._cache.set(cacheKey, {
              kind: "done",
              result: _result
            });
          }
        }
        return [updatedData !== renderData, updatedCurrentSnapshot];
      };
      _proto2.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {
        var _this7 = this;
        return Object.keys(fragmentResults).some(function(key) {
          return _this7.checkMissedUpdates(fragmentResults[key])[0];
        });
      };
      _proto2._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner, fragmentResult) {
        var _this8 = this;
        var pendingOperationsResult = getPendingOperationsForFragment(this._environment, fragmentNode, fragmentOwner);
        if (pendingOperationsResult == null) {
          return null;
        }
        var networkPromise = pendingOperationsResult.promise;
        var pendingOperations = pendingOperationsResult.pendingOperations;
        var promise = networkPromise.then(function() {
          _this8._cache["delete"](cacheKey);
        })["catch"](function(error) {
          _this8._cache["delete"](cacheKey);
        });
        promise.displayName = networkPromise.displayName;
        this._cache.set(cacheKey, {
          kind: "pending",
          pendingOperations,
          promise,
          result: fragmentResult
        });
        return {
          promise,
          pendingOperations
        };
      };
      _proto2._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx, storeEpoch) {
        var _currentFragmentResul;
        var currentFragmentResult = this._cache.get(cacheKey);
        if (isPromise(currentFragmentResult)) {
          reportInvalidCachedData(latestSnapshot.selector.node.name);
          return;
        }
        var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : (_currentFragmentResul = currentFragmentResult.result) === null || _currentFragmentResul === void 0 ? void 0 : _currentFragmentResul.snapshot;
        if (currentSnapshot && !Array.isArray(currentSnapshot)) {
          reportInvalidCachedData(latestSnapshot.selector.node.name);
          return;
        }
        var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2["default"])(currentSnapshot) : (0, _toConsumableArray2["default"])(baseSnapshots);
        nextSnapshots[idx] = latestSnapshot;
        var result = getFragmentResult(cacheKey, nextSnapshots, storeEpoch);
        if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE && result.isMissingData) {
          this._cache.set(cacheKey, {
            kind: "missing",
            result,
            snapshot: nextSnapshots
          });
        } else {
          this._cache.set(cacheKey, {
            kind: "done",
            result
          });
        }
      };
      return FragmentResourceImpl2;
    }();
    function reportInvalidCachedData(nodeName) {
      true ? true ? invariant(false, "Relay: Expected to find cached data for plural fragment `%s` when receiving a subscription. If you're seeing this, this is likely a bug in Relay.", nodeName) : invariant(false) : void 0;
    }
    function createFragmentResource(environment) {
      return new FragmentResourceImpl(environment);
    }
    var dataResources = WEAKMAP_SUPPORTED ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map();
    function getFragmentResourceForEnvironment(environment) {
      var cached = dataResources.get(environment);
      if (cached) {
        return cached;
      }
      var newDataResource = createFragmentResource(environment);
      dataResources.set(environment, newDataResource);
      return newDataResource;
    }
    module.exports = {
      createFragmentResource,
      getFragmentResourceForEnvironment
    };
  }
});

// node_modules/react-relay/lib/relay-hooks/legacy/useFragmentNode.js
var require_useFragmentNode = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/legacy/useFragmentNode.js"(exports, module) {
    "use strict";
    var useRelayEnvironment = require_useRelayEnvironment();
    var useUnsafeRef_DEPRECATED = require_useUnsafeRef_DEPRECATED();
    var _require = require_FragmentResource();
    var getFragmentResourceForEnvironment = _require.getFragmentResourceForEnvironment;
    var _require2 = require_react();
    var useEffect = _require2.useEffect;
    var useState = _require2.useState;
    var _require3 = require_relay_runtime();
    var RelayFeatureFlags = _require3.RelayFeatureFlags;
    var getFragmentIdentifier = _require3.getFragmentIdentifier;
    var warning = require_warning();
    function useFragmentNode(fragmentNode, fragmentRef, componentDisplayName) {
      var environment = useRelayEnvironment();
      var FragmentResource = getFragmentResourceForEnvironment(environment);
      var isMountedRef = useUnsafeRef_DEPRECATED(false);
      var _useState = useState(0), forceUpdate = _useState[1];
      var fragmentIdentifier = getFragmentIdentifier(fragmentNode, fragmentRef);
      var fragmentResult = FragmentResource.readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName);
      var isListeningForUpdatesRef = useUnsafeRef_DEPRECATED(true);
      function enableStoreUpdates() {
        isListeningForUpdatesRef.current = true;
        var didMissUpdates = FragmentResource.checkMissedUpdates(fragmentResult)[0];
        if (didMissUpdates) {
          handleDataUpdate();
        }
      }
      function disableStoreUpdates() {
        isListeningForUpdatesRef.current = false;
      }
      function handleDataUpdate() {
        if (isMountedRef.current === false || isListeningForUpdatesRef.current === false) {
          return;
        }
        forceUpdate(function(count) {
          return count + 1;
        });
      }
      useEffect(function() {
        isMountedRef.current = true;
        var disposable = FragmentResource.subscribe(fragmentResult, handleDataUpdate);
        return function() {
          isMountedRef.current = false;
          disposable.dispose();
        };
      }, [environment, fragmentIdentifier]);
      if (RelayFeatureFlags.LOG_MISSING_RECORDS_IN_PROD || true) {
        if (fragmentRef != null && (fragmentResult.data === void 0 || Array.isArray(fragmentResult.data) && fragmentResult.data.length > 0 && fragmentResult.data.every(function(data) {
          return data === void 0;
        }))) {
          true ? warning(false, "Relay: Expected to have been able to read non-null data for fragment `%s` declared in `%s`, since fragment reference was non-null. Make sure that that `%s`'s parent isn't holding on to and/or passing a fragment reference for data that has been deleted.", fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;
        }
      }
      return {
        data: fragmentResult.data,
        disableStoreUpdates,
        enableStoreUpdates
      };
    }
    module.exports = useFragmentNode;
  }
});

// node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js
var require_useFetchTrackingRef = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js"(exports, module) {
    "use strict";
    var useUnsafeRef_DEPRECATED = require_useUnsafeRef_DEPRECATED();
    var _require = require_react();
    var useCallback = _require.useCallback;
    var useEffect = _require.useEffect;
    function useFetchTrackingRef() {
      var subscriptionRef = useUnsafeRef_DEPRECATED(null);
      var isFetchingRef = useUnsafeRef_DEPRECATED(false);
      var disposeFetch = useCallback(function() {
        if (subscriptionRef.current != null) {
          subscriptionRef.current.unsubscribe();
          subscriptionRef.current = null;
        }
        isFetchingRef.current = false;
      }, []);
      var startFetch = useCallback(function(subscription) {
        subscriptionRef.current = subscription;
        isFetchingRef.current = true;
      }, []);
      var completeFetch = useCallback(function() {
        subscriptionRef.current = null;
        isFetchingRef.current = false;
      }, []);
      useEffect(function() {
        return disposeFetch;
      }, [disposeFetch]);
      return {
        isFetchingRef,
        startFetch,
        disposeFetch,
        completeFetch
      };
    }
    module.exports = useFetchTrackingRef;
  }
});

// node_modules/react-relay/lib/relay-hooks/useLazyLoadQueryNode.js
var require_useLazyLoadQueryNode = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useLazyLoadQueryNode.js"(exports, module) {
    "use strict";
    var HooksImplementation = require_HooksImplementation();
    var useFragmentNode = require_useFragmentNode();
    var ProfilerContext = require_ProfilerContext();
    var _require = require_QueryResource();
    var getQueryCacheIdentifier = _require.getQueryCacheIdentifier;
    var getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
    var useFetchTrackingRef = require_useFetchTrackingRef();
    var useRelayEnvironment = require_useRelayEnvironment();
    var React = require_react();
    var useContext = React.useContext;
    var useEffect = React.useEffect;
    var useState = React.useState;
    var useRef = React.useRef;
    function useLazyLoadQueryNode(_ref) {
      var query = _ref.query, componentDisplayName = _ref.componentDisplayName, fetchObservable = _ref.fetchObservable, fetchPolicy = _ref.fetchPolicy, fetchKey = _ref.fetchKey, renderPolicy = _ref.renderPolicy;
      var environment = useRelayEnvironment();
      var profilerContext = useContext(ProfilerContext);
      var QueryResource = getQueryResourceForEnvironment(environment);
      var _useState = useState(0), forceUpdateKey = _useState[0], forceUpdate = _useState[1];
      var _useFetchTrackingRef = useFetchTrackingRef(), startFetch = _useFetchTrackingRef.startFetch, completeFetch = _useFetchTrackingRef.completeFetch;
      var cacheBreaker = "".concat(forceUpdateKey, "-").concat(fetchKey !== null && fetchKey !== void 0 ? fetchKey : "");
      var cacheIdentifier = getQueryCacheIdentifier(environment, query, fetchPolicy, renderPolicy, cacheBreaker);
      var preparedQueryResult = profilerContext.wrapPrepareQueryResource(function() {
        return QueryResource.prepareWithIdentifier(cacheIdentifier, query, fetchObservable, fetchPolicy, renderPolicy, {
          start: startFetch,
          complete: completeFetch,
          error: completeFetch
        }, profilerContext);
      });
      var maybeHiddenOrFastRefresh = useRef(false);
      useEffect(function() {
        return function() {
          maybeHiddenOrFastRefresh.current = true;
        };
      }, []);
      useEffect(function() {
        if (maybeHiddenOrFastRefresh.current === true) {
          maybeHiddenOrFastRefresh.current = false;
          forceUpdate(function(n) {
            return n + 1;
          });
          return;
        }
        var disposable = QueryResource.retain(preparedQueryResult, profilerContext);
        return function() {
          disposable.dispose();
        };
      }, [environment, cacheIdentifier]);
      useEffect(function() {
        QueryResource.releaseTemporaryRetain(preparedQueryResult);
      });
      var fragmentNode = preparedQueryResult.fragmentNode, fragmentRef = preparedQueryResult.fragmentRef;
      var data = useFragmentNodeImpl(fragmentNode, fragmentRef, componentDisplayName);
      return data;
    }
    function useFragmentNodeImpl(fragment, key, componentDisplayName) {
      var impl = HooksImplementation.get();
      if (impl && impl.useFragment__internal) {
        return impl.useFragment__internal(fragment, key, componentDisplayName);
      } else {
        var _useFragmentNode = useFragmentNode(fragment, key, componentDisplayName), data = _useFragmentNode.data;
        return data;
      }
    }
    module.exports = useLazyLoadQueryNode;
  }
});

// node_modules/react-relay/lib/relay-hooks/useMemoVariables.js
var require_useMemoVariables = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useMemoVariables.js"(exports, module) {
    "use strict";
    var areEqual = require_areEqual();
    var _require = require_react();
    var useState = _require.useState;
    function useMemoVariables(variables) {
      var _useState = useState(variables), mirroredVariables = _useState[0], setMirroredVariables = _useState[1];
      if (areEqual(variables, mirroredVariables)) {
        return mirroredVariables;
      } else {
        setMirroredVariables(variables);
        return variables;
      }
    }
    module.exports = useMemoVariables;
  }
});

// node_modules/react-relay/lib/relay-hooks/useMemoOperationDescriptor.js
var require_useMemoOperationDescriptor = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useMemoOperationDescriptor.js"(exports, module) {
    "use strict";
    var useMemoVariables = require_useMemoVariables();
    var React = require_react();
    var _require = require_relay_runtime();
    var createOperationDescriptor = _require.createOperationDescriptor;
    var getRequest = _require.getRequest;
    var useMemo = React.useMemo;
    function useMemoOperationDescriptor(gqlQuery, variables, cacheConfig) {
      var memoVariables = useMemoVariables(variables);
      var memoCacheConfig = useMemoVariables(cacheConfig || {});
      return useMemo(function() {
        return createOperationDescriptor(getRequest(gqlQuery), memoVariables, memoCacheConfig);
      }, [gqlQuery, memoVariables, memoCacheConfig]);
    }
    module.exports = useMemoOperationDescriptor;
  }
});

// node_modules/react-relay/lib/relay-hooks/useLazyLoadQuery.js
var require_useLazyLoadQuery = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useLazyLoadQuery.js"(exports, module) {
    "use strict";
    var _require = require_loadQuery();
    var useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;
    var useLazyLoadQueryNode = require_useLazyLoadQueryNode();
    var useMemoOperationDescriptor = require_useMemoOperationDescriptor();
    var useRelayEnvironment = require_useRelayEnvironment();
    var _require2 = require_relay_runtime();
    var fetchQuery = _require2.__internal.fetchQuery;
    function useLazyLoadQuery(gqlQuery, variables, options) {
      useTrackLoadQueryInRender();
      var environment = useRelayEnvironment();
      var query = useMemoOperationDescriptor(gqlQuery, variables, options && options.networkCacheConfig ? options.networkCacheConfig : {
        force: true
      });
      var data = useLazyLoadQueryNode({
        componentDisplayName: "useLazyLoadQuery()",
        fetchKey: options === null || options === void 0 ? void 0 : options.fetchKey,
        fetchObservable: fetchQuery(environment, query),
        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
        query,
        renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
      });
      return data;
    }
    module.exports = useLazyLoadQuery;
  }
});

// node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js
var require_useIsMountedRef = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js"(exports, module) {
    "use strict";
    var _require = require_react();
    var useEffect = _require.useEffect;
    var useRef = _require.useRef;
    function useIsMountedRef() {
      var isMountedRef = useRef(true);
      useEffect(function() {
        isMountedRef.current = true;
        return function() {
          isMountedRef.current = false;
        };
      }, []);
      return isMountedRef;
    }
    module.exports = useIsMountedRef;
  }
});

// node_modules/react-relay/lib/relay-hooks/useEntryPointLoader.js
var require_useEntryPointLoader = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useEntryPointLoader.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var loadEntryPoint = require_loadEntryPoint();
    var _require = require_loadQuery();
    var useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;
    var useIsMountedRef = require_useIsMountedRef();
    var _require2 = require_react();
    var useCallback = _require2.useCallback;
    var useEffect = _require2.useEffect;
    var useRef = _require2.useRef;
    var useState = _require2.useState;
    var initialNullEntryPointReferenceState = {
      kind: "NullEntryPointReference"
    };
    function useLoadEntryPoint(environmentProvider, entryPoint, options) {
      var _options$TEST_ONLY__i, _options$TEST_ONLY__i2, _options$TEST_ONLY__i3, _options$TEST_ONLY__i4;
      useTrackLoadQueryInRender();
      var initialEntryPointReferenceInternal = (_options$TEST_ONLY__i = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i2 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i2 === void 0 ? void 0 : _options$TEST_ONLY__i2.entryPointReference) !== null && _options$TEST_ONLY__i !== void 0 ? _options$TEST_ONLY__i : initialNullEntryPointReferenceState;
      var initialEntryPointParamsInternal = (_options$TEST_ONLY__i3 = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i4 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i4 === void 0 ? void 0 : _options$TEST_ONLY__i4.entryPointParams) !== null && _options$TEST_ONLY__i3 !== void 0 ? _options$TEST_ONLY__i3 : null;
      var isMountedRef = useIsMountedRef();
      var undisposedEntryPointReferencesRef = useRef(/* @__PURE__ */ new Set([initialEntryPointReferenceInternal]));
      var _useState = useState(initialEntryPointReferenceInternal), entryPointReference = _useState[0], setEntryPointReference = _useState[1];
      var _useState2 = useState(initialEntryPointParamsInternal), entryPointParams = _useState2[0], setEntryPointParams = _useState2[1];
      var disposeEntryPoint = useCallback(function() {
        if (isMountedRef.current) {
          var nullEntryPointReference = {
            kind: "NullEntryPointReference"
          };
          undisposedEntryPointReferencesRef.current.add(nullEntryPointReference);
          setEntryPointReference(nullEntryPointReference);
        }
      }, [setEntryPointReference, isMountedRef]);
      var entryPointLoaderCallback = useCallback(function(params) {
        if (isMountedRef.current) {
          var updatedEntryPointReference = loadEntryPoint(environmentProvider, entryPoint, params);
          undisposedEntryPointReferencesRef.current.add(updatedEntryPointReference);
          setEntryPointReference(updatedEntryPointReference);
          setEntryPointParams(params);
        }
      }, [environmentProvider, entryPoint, setEntryPointReference, isMountedRef]);
      var maybeHiddenOrFastRefresh = useRef(false);
      useEffect(function() {
        return function() {
          maybeHiddenOrFastRefresh.current = true;
        };
      }, []);
      useEffect(function() {
        if (maybeHiddenOrFastRefresh.current === true) {
          maybeHiddenOrFastRefresh.current = false;
          if (entryPointReference.kind !== "NullEntryPointReference" && entryPointParams != null) {
            entryPointLoaderCallback(entryPointParams);
          }
          return;
        }
        var undisposedEntryPointReferences = undisposedEntryPointReferencesRef.current;
        if (isMountedRef.current) {
          var _iterator = (0, _createForOfIteratorHelper2["default"])(undisposedEntryPointReferences), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var undisposedEntryPointReference = _step.value;
              if (undisposedEntryPointReference === entryPointReference) {
                break;
              }
              undisposedEntryPointReferences["delete"](undisposedEntryPointReference);
              if (undisposedEntryPointReference.kind !== "NullEntryPointReference") {
                undisposedEntryPointReference.dispose();
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, [entryPointReference, entryPointParams, entryPointLoaderCallback, isMountedRef]);
      useEffect(function() {
        return function disposeAllRemainingEntryPointReferences() {
          var _iterator2 = (0, _createForOfIteratorHelper2["default"])(undisposedEntryPointReferencesRef.current), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var unhandledStateChange = _step2.value;
              if (unhandledStateChange.kind !== "NullEntryPointReference") {
                unhandledStateChange.dispose();
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        };
      }, []);
      return [entryPointReference.kind === "NullEntryPointReference" ? null : entryPointReference, entryPointLoaderCallback, disposeEntryPoint];
    }
    module.exports = useLoadEntryPoint;
  }
});

// node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js
var require_useStaticFragmentNodeWarning = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js"(exports, module) {
    "use strict";
    var useUnsafeRef_DEPRECATED = require_useUnsafeRef_DEPRECATED();
    var warning = require_warning();
    function useStaticFragmentNodeWarning(fragmentNode, warningContext) {
      if (true) {
        var initialPropRef = useUnsafeRef_DEPRECATED(fragmentNode.name);
        true ? warning(initialPropRef.current === fragmentNode.name, "Relay: The %s has to remain the same over the lifetime of a component. Changing it is not supported and will result in unexpected behavior.", warningContext) : void 0;
      }
    }
    module.exports = useStaticFragmentNodeWarning;
  }
});

// node_modules/react-relay/lib/relay-hooks/useFragment.js
var require_useFragment = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useFragment.js"(exports, module) {
    "use strict";
    var HooksImplementation = require_HooksImplementation();
    var useFragmentNode = require_useFragmentNode();
    var _require = require_loadQuery();
    var useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;
    var useStaticFragmentNodeWarning = require_useStaticFragmentNodeWarning();
    var _require2 = require_react();
    var useDebugValue = _require2.useDebugValue;
    var _require3 = require_relay_runtime();
    var getFragment = _require3.getFragment;
    function useFragment_LEGACY(fragment, key) {
      useTrackLoadQueryInRender();
      var fragmentNode = getFragment(fragment);
      useStaticFragmentNodeWarning(fragmentNode, "first argument of useFragment()");
      var _useFragmentNode = useFragmentNode(fragmentNode, key, "useFragment()"), data = _useFragmentNode.data;
      if (true) {
        useDebugValue({
          fragment: fragmentNode.name,
          data
        });
      }
      return data;
    }
    function useFragment(fragment, key) {
      var impl = HooksImplementation.get();
      if (impl) {
        return impl.useFragment(fragment, key);
      } else {
        return useFragment_LEGACY(fragment, key);
      }
    }
    module.exports = useFragment;
  }
});

// node_modules/react-relay/lib/relay-hooks/useMutation.js
var require_useMutation = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useMutation.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var useIsMountedRef = require_useIsMountedRef();
    var useRelayEnvironment = require_useRelayEnvironment();
    var React = require_react();
    var _require = require_relay_runtime();
    var defaultCommitMutation = _require.commitMutation;
    var useState = React.useState;
    var useEffect = React.useEffect;
    var useRef = React.useRef;
    var useCallback = React.useCallback;
    function useMutation(mutation) {
      var commitMutationFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultCommitMutation;
      var environment = useRelayEnvironment();
      var isMountedRef = useIsMountedRef();
      var environmentRef = useRef(environment);
      var mutationRef = useRef(mutation);
      var inFlightMutationsRef = useRef(/* @__PURE__ */ new Set());
      var _useState = useState(false), isMutationInFlight = _useState[0], setMutationInFlight = _useState[1];
      var cleanup = useCallback(function(disposable) {
        if (environmentRef.current === environment && mutationRef.current === mutation) {
          inFlightMutationsRef.current["delete"](disposable);
          if (isMountedRef.current) {
            setMutationInFlight(inFlightMutationsRef.current.size > 0);
          }
        }
      }, [environment, isMountedRef, mutation]);
      useEffect(function() {
        if (environmentRef.current !== environment || mutationRef.current !== mutation) {
          inFlightMutationsRef.current = /* @__PURE__ */ new Set();
          if (isMountedRef.current) {
            setMutationInFlight(false);
          }
          environmentRef.current = environment;
          mutationRef.current = mutation;
        }
      }, [environment, isMountedRef, mutation]);
      var commit = useCallback(function(config) {
        if (isMountedRef.current) {
          setMutationInFlight(true);
        }
        var disposable = commitMutationFn(environment, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, config), {}, {
          mutation,
          onCompleted: function onCompleted(response, errors) {
            var _config$onCompleted;
            cleanup(disposable);
            (_config$onCompleted = config.onCompleted) === null || _config$onCompleted === void 0 ? void 0 : _config$onCompleted.call(config, response, errors);
          },
          onError: function onError(error) {
            var _config$onError;
            cleanup(disposable);
            (_config$onError = config.onError) === null || _config$onError === void 0 ? void 0 : _config$onError.call(config, error);
          },
          onUnsubscribe: function onUnsubscribe() {
            var _config$onUnsubscribe;
            cleanup(disposable);
            (_config$onUnsubscribe = config.onUnsubscribe) === null || _config$onUnsubscribe === void 0 ? void 0 : _config$onUnsubscribe.call(config);
          },
          onNext: function onNext() {
            var _config$onNext;
            (_config$onNext = config.onNext) === null || _config$onNext === void 0 ? void 0 : _config$onNext.call(config);
          }
        }));
        inFlightMutationsRef.current.add(disposable);
        return disposable;
      }, [cleanup, commitMutationFn, environment, isMountedRef, mutation]);
      return [commit, isMutationInFlight];
    }
    module.exports = useMutation;
  }
});

// node_modules/react-relay/lib/relay-hooks/useQueryLoader.js
var require_useQueryLoader = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useQueryLoader.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var _require = require_loadQuery();
    var loadQuery = _require.loadQuery;
    var useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;
    var useIsMountedRef = require_useIsMountedRef();
    var useRelayEnvironment = require_useRelayEnvironment();
    var _require2 = require_react();
    var useCallback = _require2.useCallback;
    var useEffect = _require2.useEffect;
    var useRef = _require2.useRef;
    var useState = _require2.useState;
    var _require3 = require_relay_runtime();
    var getRequest = _require3.getRequest;
    var initialNullQueryReferenceState = {
      kind: "NullQueryReference"
    };
    function requestIsLiveQuery(preloadableRequest) {
      if (preloadableRequest.kind === "PreloadableConcreteRequest") {
        return preloadableRequest.params.metadata.live !== void 0;
      }
      var request = getRequest(preloadableRequest);
      return request.params.metadata.live !== void 0;
    }
    function useQueryLoader(preloadableRequest, initialQueryReference) {
      var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;
      var environment = useRelayEnvironment();
      useTrackLoadQueryInRender();
      var isMountedRef = useIsMountedRef();
      var undisposedQueryReferencesRef = useRef(/* @__PURE__ */ new Set([initialQueryReferenceInternal]));
      var _useState = useState(function() {
        return initialQueryReferenceInternal;
      }), queryReference = _useState[0], setQueryReference = _useState[1];
      var _useState2 = useState(function() {
        return initialQueryReferenceInternal;
      }), previousInitialQueryReference = _useState2[0], setPreviousInitialQueryReference = _useState2[1];
      if (initialQueryReferenceInternal !== previousInitialQueryReference) {
        undisposedQueryReferencesRef.current.add(initialQueryReferenceInternal);
        setPreviousInitialQueryReference(initialQueryReferenceInternal);
        setQueryReference(initialQueryReferenceInternal);
      }
      var disposeQuery = useCallback(function() {
        if (isMountedRef.current) {
          undisposedQueryReferencesRef.current.add(initialNullQueryReferenceState);
          setQueryReference(initialNullQueryReferenceState);
        }
      }, [isMountedRef]);
      var queryLoaderCallback = useCallback(function(variables, options) {
        var mergedOptions = options != null && options.hasOwnProperty("__environment") ? {
          fetchPolicy: options.fetchPolicy,
          networkCacheConfig: options.networkCacheConfig,
          __nameForWarning: options.__nameForWarning
        } : options;
        if (isMountedRef.current) {
          var _options$__environmen;
          var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);
          undisposedQueryReferencesRef.current.add(updatedQueryReference);
          setQueryReference(updatedQueryReference);
        }
      }, [environment, preloadableRequest, setQueryReference, isMountedRef]);
      var maybeHiddenOrFastRefresh = useRef(false);
      useEffect(function() {
        return function() {
          maybeHiddenOrFastRefresh.current = true;
        };
      }, []);
      useEffect(function() {
        if (maybeHiddenOrFastRefresh.current === true) {
          maybeHiddenOrFastRefresh.current = false;
          if (queryReference.kind !== "NullQueryReference") {
            queryLoaderCallback(queryReference.variables, {
              fetchPolicy: queryReference.fetchPolicy,
              networkCacheConfig: queryReference.networkCacheConfig
            });
          }
          return;
        }
        var undisposedQueryReferences = undisposedQueryReferencesRef.current;
        if (isMountedRef.current) {
          var _iterator = (0, _createForOfIteratorHelper2["default"])(undisposedQueryReferences), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var undisposedQueryReference = _step.value;
              if (undisposedQueryReference === queryReference) {
                break;
              }
              undisposedQueryReferences["delete"](undisposedQueryReference);
              if (undisposedQueryReference.kind !== "NullQueryReference") {
                if (requestIsLiveQuery(preloadableRequest)) {
                  undisposedQueryReference.dispose && undisposedQueryReference.dispose();
                } else {
                  undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, [queryReference, isMountedRef, queryLoaderCallback, preloadableRequest]);
      useEffect(function() {
        return function disposeAllRemainingQueryReferences() {
          var _iterator2 = (0, _createForOfIteratorHelper2["default"])(undisposedQueryReferencesRef.current), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var undisposedQueryReference = _step2.value;
              if (undisposedQueryReference.kind !== "NullQueryReference") {
                if (requestIsLiveQuery(preloadableRequest)) {
                  undisposedQueryReference.dispose && undisposedQueryReference.dispose();
                } else {
                  undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();
                }
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        };
      }, [preloadableRequest]);
      return [queryReference.kind === "NullQueryReference" ? null : queryReference, queryLoaderCallback, disposeQuery];
    }
    module.exports = useQueryLoader;
  }
});

// node_modules/react-relay/lib/relay-hooks/legacy/useRefetchableFragmentNode.js
var require_useRefetchableFragmentNode = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/legacy/useRefetchableFragmentNode.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var ProfilerContext = require_ProfilerContext();
    var _require = require_QueryResource();
    var getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
    var useIsMountedRef = require_useIsMountedRef();
    var useQueryLoader = require_useQueryLoader();
    var useRelayEnvironment = require_useRelayEnvironment();
    var _require2 = require_FragmentResource();
    var getFragmentResourceForEnvironment = _require2.getFragmentResourceForEnvironment;
    var useFragmentNode = require_useFragmentNode();
    var invariant = require_browser();
    var _require3 = require_react();
    var useCallback = _require3.useCallback;
    var useContext = _require3.useContext;
    var useReducer = _require3.useReducer;
    var _require4 = require_relay_runtime();
    var fetchQuery = _require4.__internal.fetchQuery;
    var createOperationDescriptor = _require4.createOperationDescriptor;
    var getFragmentIdentifier = _require4.getFragmentIdentifier;
    var getRefetchMetadata = _require4.getRefetchMetadata;
    var getSelector = _require4.getSelector;
    var getValueAtPath = _require4.getValueAtPath;
    var warning = require_warning();
    function reducer(state, action) {
      switch (action.type) {
        case "refetch": {
          var _action$refetchEnviro;
          return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, state), {}, {
            fetchPolicy: action.fetchPolicy,
            mirroredEnvironment: (_action$refetchEnviro = action.refetchEnvironment) !== null && _action$refetchEnviro !== void 0 ? _action$refetchEnviro : state.mirroredEnvironment,
            onComplete: action.onComplete,
            refetchEnvironment: action.refetchEnvironment,
            refetchQuery: action.refetchQuery,
            renderPolicy: action.renderPolicy
          });
        }
        case "reset": {
          return {
            fetchPolicy: void 0,
            mirroredEnvironment: action.environment,
            mirroredFragmentIdentifier: action.fragmentIdentifier,
            onComplete: void 0,
            refetchQuery: null,
            renderPolicy: void 0
          };
        }
        default: {
          action.type;
          throw new Error("useRefetchableFragmentNode: Unexpected action type");
        }
      }
    }
    function useRefetchableFragmentNode(fragmentNode, parentFragmentRef, componentDisplayName) {
      var parentEnvironment = useRelayEnvironment();
      var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), refetchableRequest = _getRefetchMetadata.refetchableRequest, fragmentRefPathInResponse = _getRefetchMetadata.fragmentRefPathInResponse;
      var fragmentIdentifier = getFragmentIdentifier(fragmentNode, parentFragmentRef);
      var _useReducer = useReducer(reducer, {
        fetchPolicy: void 0,
        mirroredEnvironment: parentEnvironment,
        mirroredFragmentIdentifier: fragmentIdentifier,
        onComplete: void 0,
        refetchEnvironment: null,
        refetchQuery: null,
        renderPolicy: void 0
      }), refetchState = _useReducer[0], dispatch = _useReducer[1];
      var fetchPolicy = refetchState.fetchPolicy, mirroredEnvironment = refetchState.mirroredEnvironment, mirroredFragmentIdentifier = refetchState.mirroredFragmentIdentifier, onComplete = refetchState.onComplete, refetchEnvironment = refetchState.refetchEnvironment, refetchQuery = refetchState.refetchQuery, renderPolicy = refetchState.renderPolicy;
      var environment = refetchEnvironment !== null && refetchEnvironment !== void 0 ? refetchEnvironment : parentEnvironment;
      var QueryResource = getQueryResourceForEnvironment(environment);
      var FragmentResource = getFragmentResourceForEnvironment(environment);
      var profilerContext = useContext(ProfilerContext);
      var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;
      var _useQueryLoader = useQueryLoader(refetchableRequest), queryRef = _useQueryLoader[0], loadQuery = _useQueryLoader[1], disposeQuery = _useQueryLoader[2];
      var fragmentRef = parentFragmentRef;
      var _getRefetchMetadata2 = getRefetchMetadata(fragmentNode, componentDisplayName), identifierInfo = _getRefetchMetadata2.identifierInfo;
      if (shouldReset) {
        dispatch({
          type: "reset",
          environment,
          fragmentIdentifier
        });
        disposeQuery();
      } else if (refetchQuery != null && queryRef != null) {
        var debugPreviousIDAndTypename;
        if (true) {
          debugPreviousIDAndTypename = debugFunctions.getInitialIDAndType(refetchQuery.request.variables, fragmentRefPathInResponse, identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierQueryVariableName, environment);
        }
        var handleQueryCompleted = function handleQueryCompleted2(maybeError) {
          onComplete && onComplete(maybeError !== null && maybeError !== void 0 ? maybeError : null);
        };
        var fetchObservable = queryRef.source != null ? queryRef.source : fetchQuery(environment, refetchQuery);
        var queryResult = profilerContext.wrapPrepareQueryResource(function() {
          return QueryResource.prepare(refetchQuery, fetchObservable, fetchPolicy, renderPolicy, {
            error: handleQueryCompleted,
            complete: function complete() {
              if (true) {
                debugFunctions.checkSameTypeAfterRefetch(debugPreviousIDAndTypename, environment, fragmentNode, componentDisplayName);
              }
              handleQueryCompleted();
            }
          }, queryRef.fetchKey, profilerContext);
        });
        var queryData = FragmentResource.read(queryResult.fragmentNode, queryResult.fragmentRef, componentDisplayName).data;
        !(queryData != null) ? true ? invariant(false, "Relay: Expected to be able to read refetch query response. If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
        var refetchedFragmentRef = getValueAtPath(queryData, fragmentRefPathInResponse);
        fragmentRef = refetchedFragmentRef;
        if (true) {
          debugFunctions.checkSameIDAfterRefetch(debugPreviousIDAndTypename, fragmentRef, fragmentNode, componentDisplayName);
        }
      }
      var _useFragmentNode = useFragmentNode(fragmentNode, fragmentRef, componentDisplayName), fragmentData = _useFragmentNode.data, disableStoreUpdates = _useFragmentNode.disableStoreUpdates, enableStoreUpdates = _useFragmentNode.enableStoreUpdates;
      var refetch = useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierInfo, loadQuery, parentFragmentRef, refetchableRequest);
      return {
        fragmentData,
        fragmentRef,
        refetch,
        disableStoreUpdates,
        enableStoreUpdates
      };
    }
    function useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierInfo, loadQuery, parentFragmentRef, refetchableRequest) {
      var isMountedRef = useIsMountedRef();
      var identifierValue = (identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) != null && fragmentData != null && typeof fragmentData === "object" ? fragmentData[identifierInfo.identifierField] : null;
      return useCallback(function(providedRefetchVariables, options) {
        if (isMountedRef.current !== true) {
          true ? warning(false, "Relay: Unexpected call to `refetch` on unmounted component for fragment `%s` in `%s`. It looks like some instances of your component are still trying to fetch data but they already unmounted. Please make sure you clear all timers, intervals, async calls, etc that may trigger a fetch.", fragmentNode.name, componentDisplayName) : void 0;
          return {
            dispose: function dispose() {
            }
          };
        }
        if (parentFragmentRef == null) {
          true ? warning(false, "Relay: Unexpected call to `refetch` while using a null fragment ref for fragment `%s` in `%s`. When calling `refetch`, we expect initial fragment data to be non-null. Please make sure you're passing a valid fragment ref to `%s` before calling `refetch`, or make sure you pass all required variables to `refetch`.", fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;
        }
        var refetchEnvironment = options === null || options === void 0 ? void 0 : options.__environment;
        var fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy;
        var renderPolicy = options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy;
        var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;
        var fragmentSelector = getSelector(fragmentNode, parentFragmentRef);
        var parentVariables;
        var fragmentVariables;
        if (fragmentSelector == null) {
          parentVariables = {};
          fragmentVariables = {};
        } else if (fragmentSelector.kind === "PluralReaderSelector") {
          var _fragmentSelector$sel, _fragmentSelector$sel2, _fragmentSelector$sel3, _fragmentSelector$sel4;
          parentVariables = (_fragmentSelector$sel = (_fragmentSelector$sel2 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel2 === void 0 ? void 0 : _fragmentSelector$sel2.owner.variables) !== null && _fragmentSelector$sel !== void 0 ? _fragmentSelector$sel : {};
          fragmentVariables = (_fragmentSelector$sel3 = (_fragmentSelector$sel4 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel4 === void 0 ? void 0 : _fragmentSelector$sel4.variables) !== null && _fragmentSelector$sel3 !== void 0 ? _fragmentSelector$sel3 : {};
        } else {
          parentVariables = fragmentSelector.owner.variables;
          fragmentVariables = fragmentSelector.variables;
        }
        var refetchVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, parentVariables), fragmentVariables), providedRefetchVariables);
        if (identifierInfo != null && !providedRefetchVariables.hasOwnProperty(identifierInfo.identifierQueryVariableName)) {
          if (typeof identifierValue !== "string") {
            true ? warning(false, "Relay: Expected result to have a string  `%s` in order to refetch, got `%s`.", identifierInfo.identifierField, identifierValue) : void 0;
          }
          refetchVariables[identifierInfo.identifierQueryVariableName] = identifierValue;
        }
        var refetchQuery = createOperationDescriptor(refetchableRequest, refetchVariables, {
          force: true
        });
        loadQuery(refetchQuery.request.variables, {
          fetchPolicy,
          __environment: refetchEnvironment,
          __nameForWarning: "refetch"
        });
        dispatch({
          type: "refetch",
          fetchPolicy,
          onComplete,
          refetchEnvironment,
          refetchQuery,
          renderPolicy
        });
        return {
          dispose: disposeQuery
        };
      }, [fragmentIdentifier, dispatch, disposeQuery, identifierValue, loadQuery]);
    }
    var debugFunctions;
    if (true) {
      debugFunctions = {
        getInitialIDAndType: function getInitialIDAndType(memoRefetchVariables, fragmentRefPathInResponse, identifierQueryVariableName, environment) {
          var _require5 = require_relay_runtime(), Record = _require5.Record;
          var id = memoRefetchVariables === null || memoRefetchVariables === void 0 ? void 0 : memoRefetchVariables[identifierQueryVariableName !== null && identifierQueryVariableName !== void 0 ? identifierQueryVariableName : "id"];
          if (fragmentRefPathInResponse.length !== 1 || fragmentRefPathInResponse[0] !== "node" || id == null) {
            return null;
          }
          var recordSource = environment.getStore().getSource();
          var record = recordSource.get(id);
          var typename = record == null ? null : Record.getType(record);
          if (typename == null) {
            return null;
          }
          return {
            id,
            typename
          };
        },
        checkSameTypeAfterRefetch: function checkSameTypeAfterRefetch(previousIDAndType, environment, fragmentNode, componentDisplayName) {
          var _require6 = require_relay_runtime(), Record = _require6.Record;
          if (!previousIDAndType) {
            return;
          }
          var recordSource = environment.getStore().getSource();
          var record = recordSource.get(previousIDAndType.id);
          var typename = record && Record.getType(record);
          if (typename !== previousIDAndType.typename) {
            true ? warning(false, "Relay: Call to `refetch` returned data with a different __typename: was `%s`, now `%s`, on `%s` in `%s`. Please make sure the server correctly implementsunique id requirement.", previousIDAndType.typename, typename, fragmentNode.name, componentDisplayName) : void 0;
          }
        },
        checkSameIDAfterRefetch: function checkSameIDAfterRefetch(previousIDAndTypename, refetchedFragmentRef, fragmentNode, componentDisplayName) {
          if (previousIDAndTypename == null) {
            return;
          }
          var _require7 = require_relay_runtime(), ID_KEY = _require7.ID_KEY;
          var resultID = refetchedFragmentRef[ID_KEY];
          if (resultID != null && resultID !== previousIDAndTypename.id) {
            true ? warning(false, "Relay: Call to `refetch` returned a different id, expected `%s`, got `%s`, on `%s` in `%s`. Please make sure the server correctly implements unique id requirement.", resultID, previousIDAndTypename.id, fragmentNode.name, componentDisplayName) : void 0;
          }
        }
      };
    }
    module.exports = useRefetchableFragmentNode;
  }
});

// node_modules/react-relay/lib/relay-hooks/useIsOperationNodeActive.js
var require_useIsOperationNodeActive = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useIsOperationNodeActive.js"(exports, module) {
    "use strict";
    var useRelayEnvironment = require_useRelayEnvironment();
    var invariant = require_browser();
    var React = require_react();
    var _require = require_relay_runtime();
    var getObservableForActiveRequest = _require.__internal.getObservableForActiveRequest;
    var getSelector = _require.getSelector;
    var useEffect = React.useEffect;
    var useState = React.useState;
    var useMemo = React.useMemo;
    function useIsOperationNodeActive(fragmentNode, fragmentRef) {
      var environment = useRelayEnvironment();
      var observable = useMemo(function() {
        var selector = getSelector(fragmentNode, fragmentRef);
        if (selector == null) {
          return null;
        }
        !(selector.kind === "SingularReaderSelector") ? true ? invariant(false, "useIsOperationNodeActive: Plural fragments are not supported.") : invariant(false) : void 0;
        return getObservableForActiveRequest(environment, selector.owner);
      }, [environment, fragmentNode, fragmentRef]);
      var _useState = useState(observable != null), isActive = _useState[0], setIsActive = _useState[1];
      useEffect(function() {
        var subscription;
        setIsActive(observable != null);
        if (observable != null) {
          var onCompleteOrError = function onCompleteOrError2() {
            setIsActive(false);
          };
          subscription = observable.subscribe({
            complete: onCompleteOrError,
            error: onCompleteOrError
          });
        }
        return function() {
          if (subscription) {
            subscription.unsubscribe();
          }
        };
      }, [observable]);
      return isActive;
    }
    module.exports = useIsOperationNodeActive;
  }
});

// node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction.js
var require_useLoadMoreFunction = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var useFetchTrackingRef = require_useFetchTrackingRef();
    var useIsMountedRef = require_useIsMountedRef();
    var useIsOperationNodeActive = require_useIsOperationNodeActive();
    var useRelayEnvironment = require_useRelayEnvironment();
    var invariant = require_browser();
    var _require = require_react();
    var useCallback = _require.useCallback;
    var useEffect = _require.useEffect;
    var useState = _require.useState;
    var _require2 = require_relay_runtime();
    var fetchQuery = _require2.__internal.fetchQuery;
    var ConnectionInterface = _require2.ConnectionInterface;
    var createOperationDescriptor = _require2.createOperationDescriptor;
    var getPaginationVariables = _require2.getPaginationVariables;
    var getRefetchMetadata = _require2.getRefetchMetadata;
    var getSelector = _require2.getSelector;
    var getValueAtPath = _require2.getValueAtPath;
    var warning = require_warning();
    function useLoadMoreFunction(args) {
      var direction = args.direction, fragmentNode = args.fragmentNode, fragmentRef = args.fragmentRef, fragmentIdentifier = args.fragmentIdentifier, fragmentData = args.fragmentData, connectionPathInFragmentData = args.connectionPathInFragmentData, paginationRequest = args.paginationRequest, paginationMetadata = args.paginationMetadata, componentDisplayName = args.componentDisplayName, observer = args.observer, onReset = args.onReset;
      var environment = useRelayEnvironment();
      var _useFetchTrackingRef = useFetchTrackingRef(), isFetchingRef = _useFetchTrackingRef.isFetchingRef, startFetch = _useFetchTrackingRef.startFetch, disposeFetch = _useFetchTrackingRef.disposeFetch, completeFetch = _useFetchTrackingRef.completeFetch;
      var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), identifierInfo = _getRefetchMetadata.identifierInfo;
      var identifierValue = (identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) != null && fragmentData != null && typeof fragmentData === "object" ? fragmentData[identifierInfo.identifierField] : null;
      var isMountedRef = useIsMountedRef();
      var _useState = useState(environment), mirroredEnvironment = _useState[0], setMirroredEnvironment = _useState[1];
      var _useState2 = useState(fragmentIdentifier), mirroredFragmentIdentifier = _useState2[0], setMirroredFragmentIdentifier = _useState2[1];
      var isParentQueryActive = useIsOperationNodeActive(fragmentNode, fragmentRef);
      var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;
      if (shouldReset) {
        disposeFetch();
        onReset();
        setMirroredEnvironment(environment);
        setMirroredFragmentIdentifier(fragmentIdentifier);
      }
      var _getConnectionState = getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData), cursor = _getConnectionState.cursor, hasMore = _getConnectionState.hasMore;
      useEffect(function() {
        return function() {
          disposeFetch();
        };
      }, [disposeFetch]);
      var loadMore = useCallback(function(count, options) {
        var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;
        if (isMountedRef.current !== true) {
          true ? warning(false, "Relay: Unexpected fetch on unmounted component for fragment `%s` in `%s`. It looks like some instances of your component are still trying to fetch data but they already unmounted. Please make sure you clear all timers, intervals, async calls, etc that may trigger a fetch.", fragmentNode.name, componentDisplayName) : void 0;
          return {
            dispose: function dispose() {
            }
          };
        }
        var fragmentSelector = getSelector(fragmentNode, fragmentRef);
        if (isFetchingRef.current === true || fragmentData == null || isParentQueryActive) {
          if (fragmentSelector == null) {
            true ? warning(false, "Relay: Unexpected fetch while using a null fragment ref for fragment `%s` in `%s`. When fetching more items, we expect initial fragment data to be non-null. Please make sure you're passing a valid fragment ref to `%s` before paginating.", fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;
          }
          if (onComplete) {
            onComplete(null);
          }
          return {
            dispose: function dispose() {
            }
          };
        }
        !(fragmentSelector != null && fragmentSelector.kind !== "PluralReaderSelector") ? true ? invariant(false, "Relay: Expected to be able to find a non-plural fragment owner for fragment `%s` when using `%s`. If you're seeing this, this is likely a bug in Relay.", fragmentNode.name, componentDisplayName) : invariant(false) : void 0;
        var parentVariables = fragmentSelector.owner.variables;
        var fragmentVariables = fragmentSelector.variables;
        var extraVariables = options === null || options === void 0 ? void 0 : options.UNSTABLE_extraVariables;
        var baseVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, parentVariables), fragmentVariables);
        var paginationVariables = getPaginationVariables(direction, count, cursor, baseVariables, (0, _objectSpread2["default"])({}, extraVariables), paginationMetadata);
        if (identifierInfo != null) {
          if (typeof identifierValue !== "string") {
            true ? warning(false, "Relay: Expected result to have a string  `%s` in order to refetch, got `%s`.", identifierInfo.identifierField, identifierValue) : void 0;
          }
          paginationVariables[identifierInfo.identifierQueryVariableName] = identifierValue;
        }
        var paginationQuery = createOperationDescriptor(paginationRequest, paginationVariables, {
          force: true
        });
        fetchQuery(environment, paginationQuery).subscribe((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
          start: function start(subscription) {
            startFetch(subscription);
            observer.start && observer.start(subscription);
          },
          complete: function complete() {
            completeFetch();
            observer.complete && observer.complete();
            onComplete && onComplete(null);
          },
          error: function error(_error) {
            completeFetch();
            observer.error && observer.error(_error);
            onComplete && onComplete(_error);
          }
        }));
        return {
          dispose: disposeFetch
        };
      }, [environment, identifierValue, direction, cursor, startFetch, disposeFetch, completeFetch, isFetchingRef, isParentQueryActive, fragmentData, fragmentNode.name, fragmentRef, componentDisplayName]);
      return [loadMore, hasMore, disposeFetch];
    }
    function getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData) {
      var _pageInfo$END_CURSOR, _pageInfo$START_CURSO;
      var _ConnectionInterface$ = ConnectionInterface.get(), EDGES = _ConnectionInterface$.EDGES, PAGE_INFO = _ConnectionInterface$.PAGE_INFO, HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE, HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE, END_CURSOR = _ConnectionInterface$.END_CURSOR, START_CURSOR = _ConnectionInterface$.START_CURSOR;
      var connection = getValueAtPath(fragmentData, connectionPathInFragmentData);
      if (connection == null) {
        return {
          cursor: null,
          hasMore: false
        };
      }
      !(typeof connection === "object") ? true ? invariant(false, "Relay: Expected connection in fragment `%s` to have been `null`, or a plain object with %s and %s properties. Instead got `%s`.", fragmentNode.name, EDGES, PAGE_INFO, connection) : invariant(false) : void 0;
      var edges = connection[EDGES];
      var pageInfo = connection[PAGE_INFO];
      if (edges == null || pageInfo == null) {
        return {
          cursor: null,
          hasMore: false
        };
      }
      !Array.isArray(edges) ? true ? invariant(false, "Relay: Expected connection in fragment `%s` to have a plural `%s` field. Instead got `%s`.", fragmentNode.name, EDGES, edges) : invariant(false) : void 0;
      !(typeof pageInfo === "object") ? true ? invariant(false, "Relay: Expected connection in fragment `%s` to have a `%s` field. Instead got `%s`.", fragmentNode.name, PAGE_INFO, pageInfo) : invariant(false) : void 0;
      var cursor = direction === "forward" ? (_pageInfo$END_CURSOR = pageInfo[END_CURSOR]) !== null && _pageInfo$END_CURSOR !== void 0 ? _pageInfo$END_CURSOR : null : (_pageInfo$START_CURSO = pageInfo[START_CURSOR]) !== null && _pageInfo$START_CURSO !== void 0 ? _pageInfo$START_CURSO : null;
      !(cursor === null || typeof cursor === "string") ? true ? invariant(false, "Relay: Expected page info for connection in fragment `%s` to have a valid `%s`. Instead got `%s`.", fragmentNode.name, START_CURSOR, cursor) : invariant(false) : void 0;
      var hasMore;
      if (direction === "forward") {
        hasMore = cursor != null && pageInfo[HAS_NEXT_PAGE] === true;
      } else {
        hasMore = cursor != null && pageInfo[HAS_PREV_PAGE] === true;
      }
      return {
        cursor,
        hasMore
      };
    }
    module.exports = useLoadMoreFunction;
  }
});

// node_modules/react-relay/lib/relay-hooks/usePaginationFragment.js
var require_usePaginationFragment = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/usePaginationFragment.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var HooksImplementation = require_HooksImplementation();
    var useRefetchableFragmentNode = require_useRefetchableFragmentNode();
    var useLoadMoreFunction = require_useLoadMoreFunction();
    var useStaticFragmentNodeWarning = require_useStaticFragmentNodeWarning();
    var _require = require_react();
    var useCallback = _require.useCallback;
    var useDebugValue = _require.useDebugValue;
    var useState = _require.useState;
    var _require2 = require_relay_runtime();
    var getFragment = _require2.getFragment;
    var getFragmentIdentifier = _require2.getFragmentIdentifier;
    var getPaginationMetadata = _require2.getPaginationMetadata;
    function usePaginationFragment_LEGACY(fragmentInput, parentFragmentRef) {
      var fragmentNode = getFragment(fragmentInput);
      useStaticFragmentNodeWarning(fragmentNode, "first argument of usePaginationFragment()");
      var componentDisplayName = "usePaginationFragment()";
      var _getPaginationMetadat = getPaginationMetadata(fragmentNode, componentDisplayName), connectionPathInFragmentData = _getPaginationMetadat.connectionPathInFragmentData, paginationRequest = _getPaginationMetadat.paginationRequest, paginationMetadata = _getPaginationMetadat.paginationMetadata;
      var _useRefetchableFragme = useRefetchableFragmentNode(fragmentNode, parentFragmentRef, componentDisplayName), fragmentData = _useRefetchableFragme.fragmentData, fragmentRef = _useRefetchableFragme.fragmentRef, refetch = _useRefetchableFragme.refetch;
      var fragmentIdentifier = getFragmentIdentifier(fragmentNode, fragmentRef);
      var _useLoadMore = useLoadMore({
        componentDisplayName,
        connectionPathInFragmentData,
        direction: "backward",
        fragmentData,
        fragmentIdentifier,
        fragmentNode,
        fragmentRef,
        paginationMetadata,
        paginationRequest
      }), loadPrevious = _useLoadMore[0], hasPrevious = _useLoadMore[1], isLoadingPrevious = _useLoadMore[2], disposeFetchPrevious = _useLoadMore[3];
      var _useLoadMore2 = useLoadMore({
        componentDisplayName,
        connectionPathInFragmentData,
        direction: "forward",
        fragmentData,
        fragmentIdentifier,
        fragmentNode,
        fragmentRef,
        paginationMetadata,
        paginationRequest
      }), loadNext = _useLoadMore2[0], hasNext = _useLoadMore2[1], isLoadingNext = _useLoadMore2[2], disposeFetchNext = _useLoadMore2[3];
      var refetchPagination = useCallback(function(variables, options) {
        disposeFetchNext();
        disposeFetchPrevious();
        return refetch(variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options), {}, {
          __environment: void 0
        }));
      }, [disposeFetchNext, disposeFetchPrevious, refetch]);
      if (true) {
        useDebugValue({
          fragment: fragmentNode.name,
          data: fragmentData,
          hasNext,
          isLoadingNext,
          hasPrevious,
          isLoadingPrevious
        });
      }
      return {
        data: fragmentData,
        loadNext,
        loadPrevious,
        hasNext,
        hasPrevious,
        isLoadingNext,
        isLoadingPrevious,
        refetch: refetchPagination
      };
    }
    function useLoadMore(args) {
      var _useState = useState(false), isLoadingMore = _useState[0], setIsLoadingMore = _useState[1];
      var observer = {
        start: function start() {
          return setIsLoadingMore(true);
        },
        complete: function complete() {
          return setIsLoadingMore(false);
        },
        error: function error() {
          return setIsLoadingMore(false);
        }
      };
      var handleReset = function handleReset2() {
        return setIsLoadingMore(false);
      };
      var _useLoadMoreFunction = useLoadMoreFunction((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, args), {}, {
        observer,
        onReset: handleReset
      })), loadMore = _useLoadMoreFunction[0], hasMore = _useLoadMoreFunction[1], disposeFetch = _useLoadMoreFunction[2];
      return [loadMore, hasMore, isLoadingMore, disposeFetch];
    }
    function usePaginationFragment(fragmentInput, parentFragmentRef) {
      var impl = HooksImplementation.get();
      if (impl) {
        return impl.usePaginationFragment(fragmentInput, parentFragmentRef);
      } else {
        return usePaginationFragment_LEGACY(fragmentInput, parentFragmentRef);
      }
    }
    module.exports = usePaginationFragment;
  }
});

// node_modules/react-relay/lib/relay-hooks/usePreloadedQuery.js
var require_usePreloadedQuery = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/usePreloadedQuery.js"(exports, module) {
    "use strict";
    var _require = require_loadQuery();
    var useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;
    var useLazyLoadQueryNode = require_useLazyLoadQueryNode();
    var useMemoOperationDescriptor = require_useMemoOperationDescriptor();
    var useRelayEnvironment = require_useRelayEnvironment();
    var invariant = require_browser();
    var _require2 = require_react();
    var useDebugValue = _require2.useDebugValue;
    var _require3 = require_relay_runtime();
    var _require3$__internal = _require3.__internal;
    var fetchQueryDeduped = _require3$__internal.fetchQueryDeduped;
    var fetchQuery = _require3$__internal.fetchQuery;
    var warning = require_warning();
    function usePreloadedQuery(gqlQuery, preloadedQuery, options) {
      useTrackLoadQueryInRender();
      var environment = useRelayEnvironment();
      var fetchKey = preloadedQuery.fetchKey, fetchPolicy = preloadedQuery.fetchPolicy, source = preloadedQuery.source, variables = preloadedQuery.variables, networkCacheConfig = preloadedQuery.networkCacheConfig;
      var operation = useMemoOperationDescriptor(gqlQuery, variables, networkCacheConfig);
      var useLazyLoadQueryNodeParams;
      if (preloadedQuery.kind === "PreloadedQuery_DEPRECATED") {
        !(operation.request.node.params.name === preloadedQuery.name) ? true ? invariant(false, "usePreloadedQuery(): Expected data to be prefetched for query `%s`, got prefetch results for query `%s`.", operation.request.node.params.name, preloadedQuery.name) : invariant(false) : void 0;
        useLazyLoadQueryNodeParams = {
          componentDisplayName: "usePreloadedQuery()",
          fetchKey,
          fetchObservable: fetchQueryDeduped(environment, operation.request.identifier, function() {
            if (environment === preloadedQuery.environment && source != null) {
              return environment.executeWithSource({
                operation,
                source
              });
            } else {
              return environment.execute({
                operation
              });
            }
          }),
          fetchPolicy,
          query: operation,
          renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
        };
      } else {
        true ? warning(preloadedQuery.isDisposed === false, "usePreloadedQuery(): Expected preloadedQuery to not be disposed yet. This is because disposing the query marks it for future garbage collection, and as such query results may no longer be present in the Relay store. In the future, this will become a hard error.") : void 0;
        var fallbackFetchObservable = fetchQuery(environment, operation);
        var fetchObservable;
        if (source != null && environment === preloadedQuery.environment) {
          fetchObservable = source.ifEmpty(fallbackFetchObservable);
        } else if (environment !== preloadedQuery.environment) {
          true ? warning(false, "usePreloadedQuery(): usePreloadedQuery was passed a preloaded query that was created with a different environment than the one that is currently in context. In the future, this will become a hard error.") : void 0;
          fetchObservable = fallbackFetchObservable;
        } else {
          fetchObservable = fallbackFetchObservable;
        }
        useLazyLoadQueryNodeParams = {
          componentDisplayName: "usePreloadedQuery()",
          fetchObservable,
          fetchKey,
          fetchPolicy,
          query: operation,
          renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
        };
      }
      var data = useLazyLoadQueryNode(useLazyLoadQueryNodeParams);
      if (true) {
        useDebugValue({
          query: preloadedQuery.name,
          variables: preloadedQuery.variables,
          data,
          fetchKey,
          fetchPolicy,
          renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
        });
      }
      return data;
    }
    module.exports = usePreloadedQuery;
  }
});

// node_modules/react-relay/lib/relay-hooks/useRefetchableFragment.js
var require_useRefetchableFragment = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useRefetchableFragment.js"(exports, module) {
    "use strict";
    var HooksImplementation = require_HooksImplementation();
    var useRefetchableFragmentNode = require_useRefetchableFragmentNode();
    var useStaticFragmentNodeWarning = require_useStaticFragmentNodeWarning();
    var _require = require_react();
    var useDebugValue = _require.useDebugValue;
    var _require2 = require_relay_runtime();
    var getFragment = _require2.getFragment;
    function useRefetchableFragment_LEGACY(fragmentInput, fragmentRef) {
      var fragmentNode = getFragment(fragmentInput);
      useStaticFragmentNodeWarning(fragmentNode, "first argument of useRefetchableFragment()");
      var _useRefetchableFragme = useRefetchableFragmentNode(fragmentNode, fragmentRef, "useRefetchableFragment()"), fragmentData = _useRefetchableFragme.fragmentData, refetch = _useRefetchableFragme.refetch;
      if (true) {
        useDebugValue({
          fragment: fragmentNode.name,
          data: fragmentData
        });
      }
      return [fragmentData, refetch];
    }
    function useRefetchableFragment(fragmentInput, parentFragmentRef) {
      var impl = HooksImplementation.get();
      if (impl) {
        return impl.useRefetchableFragment(fragmentInput, parentFragmentRef);
      } else {
        return useRefetchableFragment_LEGACY(fragmentInput, parentFragmentRef);
      }
    }
    module.exports = useRefetchableFragment;
  }
});

// node_modules/react-relay/lib/relay-hooks/useSubscribeToInvalidationState.js
var require_useSubscribeToInvalidationState = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useSubscribeToInvalidationState.js"(exports, module) {
    "use strict";
    var useRelayEnvironment = require_useRelayEnvironment();
    var _require = require_react();
    var useEffect = _require.useEffect;
    var useRef = _require.useRef;
    function useSubscribeToInvalidationState(dataIDs, callback) {
      var environment = useRelayEnvironment();
      var disposableRef = useRef(null);
      var stableDataIDs = Array.from(dataIDs).sort().join("");
      useEffect(function() {
        var store = environment.getStore();
        var invalidationState = store.lookupInvalidationState(dataIDs);
        var disposable = store.subscribeToInvalidationState(invalidationState, callback);
        disposableRef.current = disposable;
        return function() {
          return disposable.dispose();
        };
      }, [stableDataIDs, callback, environment]);
      return {
        dispose: function dispose() {
          if (disposableRef.current != null) {
            disposableRef.current.dispose();
          }
        }
      };
    }
    module.exports = useSubscribeToInvalidationState;
  }
});

// node_modules/react-relay/lib/relay-hooks/useSubscription.js
var require_useSubscription = __commonJS({
  "node_modules/react-relay/lib/relay-hooks/useSubscription.js"(exports, module) {
    "use strict";
    var useRelayEnvironment = require_useRelayEnvironment();
    var _require = require_react();
    var useEffect = _require.useEffect;
    var _require2 = require_relay_runtime();
    var requestSubscription = _require2.requestSubscription;
    function useSubscription(config, requestSubscriptionFn) {
      var actualRequestSubscription = requestSubscriptionFn !== null && requestSubscriptionFn !== void 0 ? requestSubscriptionFn : requestSubscription;
      var environment = useRelayEnvironment();
      useEffect(function() {
        var _actualRequestSubscri = actualRequestSubscription(environment, config), dispose = _actualRequestSubscri.dispose;
        return dispose;
      }, [environment, config, actualRequestSubscription]);
    }
    module.exports = useSubscription;
  }
});

export {
  require_ReactRelayContext,
  require_ProfilerContext,
  require_useRelayEnvironment,
  require_EntryPointContainer_react,
  require_loadQuery,
  require_loadEntryPoint,
  require_RelayEnvironmentProvider,
  require_useLazyLoadQuery,
  require_useEntryPointLoader,
  require_useFragment,
  require_useMutation,
  require_useQueryLoader,
  require_usePaginationFragment,
  require_usePreloadedQuery,
  require_useRefetchableFragment,
  require_useSubscribeToInvalidationState,
  require_useSubscription
};
//# sourceMappingURL=chunk-WHWY5NIJ.js.map
